<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git版本回退方法</title>
    <url>/2020/08/26/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>今天在公司犯了错误，在公司公共的develop分支上push了错误的代码，顺便研究了一下git如何回退版本，参考了大佬的做法，记录下了这篇博客。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果提交了一个错误的版本，怎么回退版本？</p>
<p>如果提交了一个错误的版本到远程分支，怎么回退远程分支版本？</p>
<p>如果提交了一个错误的版本到公共远程分支，又该怎么回退版本？</p>
<a id="more"></a>

<h3 id="本地分支版本回退的方法"><a href="#本地分支版本回退的方法" class="headerlink" title="本地分支版本回退的方法"></a>本地分支版本回退的方法</h3><p>如果你在本地做了错误提交，那么回退版本的方法很简单</p>
<p>先用下面命令找到要回退的版本的commit id：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<p>接着回退版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard Obfafd</span><br></pre></td></tr></table></figure>

<p>0bfafd就是你要回退的版本的commit id的前面几位</p>
<h3 id="自己的远程分支版本回退的方法"><a href="#自己的远程分支版本回退的方法" class="headerlink" title="自己的远程分支版本回退的方法"></a>自己的远程分支版本回退的方法</h3><p>如果你的错误提交已经推送到自己的远程分支了，那么就需要回滚远程分支了。<br>首先要回退本地分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard Obfafd</span><br></pre></td></tr></table></figure>

<p>紧接着强制推送到远程分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -f origin develop</span><br></pre></td></tr></table></figure>

<p><strong>注意：本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支</strong></p>
<h3 id="公共远程分支版本回退的方法"><a href="#公共远程分支版本回退的方法" class="headerlink" title="公共远程分支版本回退的方法"></a>公共远程分支版本回退的方法</h3><p>使用git reset回退公共远程分支的版本后，需要其他所有人手动用远程master分支覆盖本地master分支，</p>
<p>显然，这不是优雅的回退方法，下面我们使用另个一个命令来回退版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert HEAD                     //撤销最近一次提交</span><br><span class="line">git revert HEAD~1                   //撤销上上次的提交，注意：数字从0开始</span><br><span class="line">git revert 0ffaacc                  //撤销0ffaacc这次提交</span><br></pre></td></tr></table></figure>

<p>git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是<strong>版本依然是向前的</strong>，</p>
<p>所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。</p>
<p>但是，要注意以下几点：</p>
<ol>
<li><p>revert 是撤销一次提交，所以后面的commit id是你需要回滚到的版本的前一次提交</p>
</li>
<li><p>使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的</p>
</li>
<li><p>使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。</p>
</li>
<li><p>如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了.</p>
</li>
</ol>
<p>git revert 命令的好处就是<strong>不会丢掉别人的提交</strong>，即使你撤销后覆盖了别人的提交，他更新代码后，可以在本地用 reset 向前回滚，找到自己的代码，然后拉一下分支，再回来合并上去就可以找回被你覆盖的提交了。</p>
<h3 id="继续扩展，简单粗暴的回滚方法"><a href="#继续扩展，简单粗暴的回滚方法" class="headerlink" title="继续扩展，简单粗暴的回滚方法"></a>继续扩展，简单粗暴的回滚方法</h3><p>看到这里也许你已经觉得学会了远程仓库版本回滚方法了，但是实践中总是会遇到很多不按套路来的问题，考虑下面一种情况：</p>
<p>如果你们开发中，忽然发现前面很远的地方有一次错误的合并代码，把本来下一次才能发的功能的代码合并到了这一次来了，这个时候全体成员都觉得直接回滚比较快，因为他们都有备份，覆盖了无所谓，这个时候用reset的话对队友的要求比较高，用revert的话呢要大面积的解决冲突，也很麻烦呀，怎么办呢？</p>
<p>这个时候，可以使用简单粗暴的办法，直接从那个错误的提交的前一次拉取一份代码放到其他目录，然后将master代码全部删除，把那份新代码方进去，然后提交，果然简单粗暴啊，虽然这种方法不入流，但是，实践中发现很好使啊，所以，实践是检验真理的唯一标准。遇到问题还是要灵活应对。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>远程分支回滚的三种方法：</p>
<ol>
<li><p>自己的分支回滚直接用reset</p>
</li>
<li><p>公共分支回滚用revert</p>
</li>
<li><p>错的太远了直接将代码全部删掉，用正确代码替代</p>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/fuchaosz/article/details/52170105" target="_blank" rel="noopener">http://blog.csdn.net/fuchaosz/article/details/52170105</a></p>
]]></content>
  </entry>
  <entry>
    <title>ControllerAdvice和ErrorController的用法</title>
    <url>/2020/07/14/ControllerAdvice%E5%92%8CErrorController%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Java中异常可以分为Error和Exception，<strong>@ControllerAdvice</strong>用来处理系统中的<strong>Exception</strong>，<strong>Error</strong>Controller处理系统中的<strong>Error</strong>。</p>
<a id="more"></a>

<h2 id="ErrorController"><a href="#ErrorController" class="headerlink" title="ErrorController"></a>ErrorController</h2><p>在项目中我们遇到404找不到的错误、或者500服务器错误都需要配置相应的页面给用户一个友好的提示，而在Spring Boot中我们需要如何设置。</p>
<p>当系统出现404或者405等错误信息时，springboot默认的访问路径为/error，所以实现ErrorController并重写。</p>
<h3 id="ErrorController源码"><a href="#ErrorController源码" class="headerlink" title="ErrorController源码"></a>ErrorController源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.web.servlet.error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marker interface used to indicate that a &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125; is used to</span></span><br><span class="line"><span class="comment"> * render errors. Primarily used to know the error paths that will not need to be secured.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the path of the error page.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the error path</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">getErrorPath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写ErrorController样例"><a href="#重写ErrorController样例" class="headerlink" title="重写ErrorController样例"></a>重写ErrorController样例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局Error/404处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> geekidea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiIgnore</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalErrorController</span> <span class="keyword">implements</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_PATH = <span class="string">"/error"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(ERROR_PATH)</span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;?&gt; handleError(HttpServletRequest request,HttpServletResponse response)&#123;</span><br><span class="line">        <span class="keyword">int</span> status = response.getStatus();</span><br><span class="line">        <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">            <span class="keyword">case</span> HttpServletResponse.SC_UNAUTHORIZED:</span><br><span class="line">                <span class="keyword">return</span> ApiResult.fail(ApiCode.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">case</span> HttpServletResponse.SC_FORBIDDEN:</span><br><span class="line">                <span class="keyword">return</span> ApiResult.fail(ApiCode.NOT_PERMISSION);</span><br><span class="line">            <span class="keyword">case</span> HttpServletResponse.SC_NOT_FOUND:</span><br><span class="line">                <span class="keyword">return</span> ApiResult.fail(ApiCode.NOT_FOUND);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.FAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"errorPath...."</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_PATH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>ControllerAdvice用来处理发生Exception错误的注解。需要注意的是不能使用try catch 捕获</p>
<h3 id="ControllerAdvice样例"><a href="#ControllerAdvice样例" class="headerlink" title="@ControllerAdvice样例"></a>@ControllerAdvice样例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> geekidea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非法参数验证异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.OK)</span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;List&lt;String&gt;&gt; handleMethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        BindingResult bindingResult = ex.getBindingResult();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors();</span><br><span class="line">        <span class="keyword">for</span> (FieldError fieldError : fieldErrors) &#123;</span><br><span class="line">            list.add(fieldError.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        log.error(getApiCodeString(ApiCode.PARAMETER_EXCEPTION) + <span class="string">":"</span> + JSON.toJSONString(list));</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.PARAMETER_EXCEPTION, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统登录异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = SysLoginException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">sysLoginExceptionHandler</span>(<span class="title">SysLoginException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.LOGIN_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.LOGIN_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HTTP解析请求参数异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = HttpMessageNotReadableException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">httpMessageNotReadableException</span>(<span class="title">HttpMessageNotReadableException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.PARAMETER_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.PARAMETER_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HTTP</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = HttpMediaTypeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">httpMediaTypeException</span>(<span class="title">HttpMediaTypeException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.HTTP_MEDIA_TYPE_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.HTTP_MEDIA_TYPE_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义业务/数据异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = &#123;SpringBootPlusException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">springBootPlusExceptionHandler</span>(<span class="title">SpringBootPlusException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        log.error(<span class="string">"springBootPlusException:"</span>, exception);</span><br><span class="line">        <span class="keyword">int</span> errorCode;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            errorCode = ApiCode.BUSINESS_EXCEPTION.getCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DaoException) &#123;</span><br><span class="line">            errorCode = ApiCode.DAO_EXCEPTION.getCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> VerificationCodeException) &#123;</span><br><span class="line">            errorCode = ApiCode.VERIFICATION_CODE_EXCEPTION.getCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errorCode = ApiCode.SPRING_BOOT_PLUS_EXCEPTION.getCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult&lt;Boolean&gt;()</span><br><span class="line">                .setCode(errorCode)</span><br><span class="line">                .setMessage(exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录授权异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = AuthenticationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">authenticationExceptionHandler</span>(<span class="title">AuthenticationException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.AUTHENTICATION_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.AUTHENTICATION_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未认证异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = UnauthenticatedException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">unauthenticatedExceptionHandler</span>(<span class="title">UnauthenticatedException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.UNAUTHENTICATED_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.UNAUTHENTICATED_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未授权异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = UnauthorizedException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">unauthorizedExceptionHandler</span>(<span class="title">UnauthorizedException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.UNAUTHORIZED_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.UNAUTHORIZED_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JWT Token解析异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = JWTDecodeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">jWTDecodeExceptionHandler</span>(<span class="title">JWTDecodeException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.JWTDECODE_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.JWTDECODE_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = HttpRequestMethodNotSupportedException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">String</span>&gt; <span class="title">httpRequestMethodNotSupportedExceptionHandler</span>(<span class="title">Exception</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.HTTP_REQUEST_METHOD_NOT_SUPPORTED_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.HTTP_REQUEST_METHOD_NOT_SUPPORTED_EXCEPTION.getCode(), exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">exceptionHandler</span>(<span class="title">Exception</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.SYSTEM_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.SYSTEM_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印请求详情</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printRequestDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestDetail requestDetail = RequestDetailThreadLocal.getRequestDetail();</span><br><span class="line">        <span class="keyword">if</span> (requestDetail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"异常来源：ip: &#123;&#125;, path: &#123;&#125;"</span>, requestDetail.getIp(), requestDetail.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ApiCode格式化字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apiCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getApiCodeString</span><span class="params">(ApiCode apiCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apiCode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">"errorCode: %s, errorMessage: %s"</span>, apiCode.getCode(), apiCode.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印错误码及异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apiCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printApiCodeException</span><span class="params">(ApiCode apiCode, Exception exception)</span> </span>&#123;</span><br><span class="line">        log.error(getApiCodeString(apiCode), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>IntelliJ-IDEA-高级调试技巧</title>
    <url>/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="一、条件断点"><a href="#一、条件断点" class="headerlink" title="一、条件断点"></a>一、条件断点</h2><p>循环中经常用到这个技巧，比如：遍历1个大List的过程中，想让断点停在某个特定值。</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/condition.png" class="" title="condition">

<p>参考上图，在断点的位置，右击断点旁边的小红点，会出来一个界面，在Condition这里填入断点条件即可，这样调试时，就会自动停在i=10的位置</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/condition_result.png" class="" title="condition_result">

<a id="more"></a>

<h2 id="二、回到”上一步”"><a href="#二、回到”上一步”" class="headerlink" title="二、回到”上一步”"></a>二、回到”上一步”</h2><p>该技巧最适合特别复杂的方法套方法的场景，好不容易跑起来，一不小心手一抖，断点过去了，想回过头看看刚才的变量值，如果不知道该技巧，只能再跑一遍。</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/back.png" class="" title="back">

<p>参考上图，method1方法调用method2，当前断点的位置j=100，点击上图红色箭头位置的Drop Frame图标后，时间穿越了</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/back_result.png" class="" title="back_result">

<p>回到了method1刚开始调用的时候，变量i变成了99，没毛病吧，老铁们，是不是很6 :)</p>
<p>注：好奇心是人类进步的阶梯，如果想知道为啥这个功能叫Drop Frame，而不是类似Back To Previous 之类的，可以去翻翻JVM的书，JVM内部以栈帧为单位保存线程的运行状态，drop frame即扔掉当前运行的栈帧，这样当前“指针”的位置，就自然到了上一帧的位置。</p>
<h2 id="三、多线程调试"><a href="#三、多线程调试" class="headerlink" title="三、多线程调试"></a>三、多线程调试</h2><p>多线程同时运行时，谁先执行，谁后执行，完全是看CPU心情的，无法控制先后，运行时可能没什么问题，但是调试时就比较麻烦了，最明显的就是断点乱跳，一会儿停这个线程，一会儿停在另一个线程，比如下图：</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/thread.png" class="" title="thread">

<p>如果想希望下一个断点位置是第2句诗句，可能要失望了：</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/thread2.png" class="" title="thread2">

<p>如果想让线程在调试时，想按自己的愿意来，让它停在哪个线程就停在哪个线程，可以在图中3个断点的小红点上右击，</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/suspend.png" class="" title="suspend">

<p>即：Suspend挂起的条件是按每个线程来，而非All。把这3个断点都这么设置后，再来一发试试</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/sus_result.png" class="" title="sus_result">

<p>注意上图中的红框位置，断点停下来时，这个下拉框可以看到各个线程（注：给线程起个容易识别的名字是个好习惯！），我们可以选择线程“天空中的飞鸟”</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/choose.png" class="" title="choose">

<p>断点如愿停在了第2句诗。</p>
<h2 id="四、远程调试"><a href="#四、远程调试" class="headerlink" title="四、远程调试"></a>四、远程调试</h2><p>这也是一个装B的利器，本机不用启动项目，只要有源代码，可以在本机直接远程调试服务器上的代码，打开姿势如下：</p>
<h3 id="4-1-项目启动时，先允许远程调试"><a href="#4-1-项目启动时，先允许远程调试" class="headerlink" title="4.1 项目启动时，先允许远程调试"></a>4.1 项目启动时，先允许远程调试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -server -Xms512m -Xmx512m -Xdebug -Xnoagent -Djava.compiler&#x3D;NONE -Xrunjdwp:transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;9081 -Djava.ext.dirs&#x3D;. $&#123;main_class&#125;</span><br></pre></td></tr></table></figure>

<p>起作用的就是</p>
<p>-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9081</p>
<p>注意：远程调试从技术上讲，就是在本机与远程建立scoket通讯，所以端口不要冲突，而且本机要允许访问远程端口，另外这一段参数，放要在-jar 或 ${main_class}的前面</p>
<h3 id="4-2-idea中设置远程调试"><a href="#4-2-idea中设置远程调试" class="headerlink" title="4.2 idea中设置远程调试"></a>4.2 idea中设置远程调试</h3><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/remote.png" class="" title="remote">

<p>然后就可以调试了</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/remote_test.png" class="" title="remote_test">

<p>前提是本机有项目的源代码 ，在需要的地方打个断点，然后访问一个远程的url试试，断点就会停下来。</p>
<h2 id="五、临时执行表达式-修改变量的运行值"><a href="#五、临时执行表达式-修改变量的运行值" class="headerlink" title="五、临时执行表达式/修改变量的运行值"></a>五、临时执行表达式/修改变量的运行值</h2><p>调试时，可以临时执行一些表达式，参考下图：点击这二个图标中的任何1个都可以</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/change.png" class="" title="change">

<p>点击+号后，就可以在新出现的输入框里输入表达式，比如i+5</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/input.png" class="" title="input">

<p>然后回车，马上就能看到结果 </p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/return.png" class="" title="return">

<p>当然，如果调试时，想动态修改变量的值，也很容易，在变量上右击，然后选择Set Value，剩下的事，地球人都知道。</p>
<img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/set_value.png" class="" title="set_value">

<p>善用上述调试技巧，相当大家撸起代码来会更有感觉，祝大家端午节愉快！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/jun1019/p/9741224.html" target="_blank" rel="noopener">https://www.cnblogs.com/jun1019/p/9741224.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>Jackson的使用</title>
    <url>/2020/07/10/Jackson%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近公司的竞技场项目中使用了jackson来进行java对象和json的相互转换</p>
<p>下面来介绍一下jackson的简单使用</p>
<a id="more"></a>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.6&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="第1步：创建ObjectMapper对象"><a href="#第1步：创建ObjectMapper对象" class="headerlink" title="第1步：创建ObjectMapper对象"></a>第1步：创建ObjectMapper对象</h3><p>创建ObjectMapper对象。它是一个可重复使用的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br></pre></td></tr></table></figure>

<h3 id="第2步：反序列化JSON到对象"><a href="#第2步：反序列化JSON到对象" class="headerlink" title="第2步：反序列化JSON到对象"></a>第2步：反序列化JSON到对象</h3><p>从JSON对象使用readValue()方法来获取。通过JSON字符串和对象类型作为参数JSON字符串/来源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object to JSON Conversion</span></span><br><span class="line">Student student = mapper.readValue(jsonString, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="第3步：序列化对象到JSON"><a href="#第3步：序列化对象到JSON" class="headerlink" title="第3步：序列化对象到JSON"></a>第3步：序列化对象到JSON</h3><p>使用writeValueAsString()方法来获取对象的JSON字符串表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object to JSON Conversion		</span></span><br><span class="line">jsonString = mapper.writeValueAsString(student);</span><br></pre></td></tr></table></figure>

<h2 id="信息配置-对mapper的设置"><a href="#信息配置-对mapper的设置" class="headerlink" title="信息配置 对mapper的设置"></a>信息配置 对mapper的设置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在反序列化时忽略在 json 中存在但 Java 对象不存在的属性</span></span><br><span class="line">mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,</span><br><span class="line">   <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//在序列化时日期格式默认为 yyyy-MM-dd'T'HH:mm:ss.SSSZ</span></span><br><span class="line">mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,<span class="keyword">false</span>)</span><br><span class="line"><span class="comment">//在序列化时忽略值为 null 的属性</span></span><br><span class="line">mapper.setSerializationInclusion(Include.NON_NULL);</span><br><span class="line"><span class="comment">//忽略值为默认值的属性</span></span><br><span class="line">mapper.setDefaultPropertyInclusion(Include.NON_DEFAULT);</span><br></pre></td></tr></table></figure>

<h2 id="Jackson的注解的使用"><a href="#Jackson的注解的使用" class="headerlink" title="Jackson的注解的使用"></a>Jackson的注解的使用</h2><p>Jackson的常用注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>@JsonProperty</td>
<td>用于属性，把属性的名称序列化时转换为另外一个名称。示例： @JsonProperty(“birth_ d ate”) private Date birthDate;</td>
</tr>
<tr>
<td>@JsonFormat</td>
<td>用于属性或者方法，把属性的格式序列化时转换成指定的格式。示例： @JsonFormat(timezone = “GMT+8”, pattern = “yyyy-MM-dd HH:mm” public Date getBirthDate()</td>
</tr>
<tr>
<td>@JsonPropertyOrder</td>
<td>用于类， 指定属性在序列化时 json 中的顺序 ， 示例： @JsonPropertyOrder({ “birth_Date”, “name” }) public class Person</td>
</tr>
<tr>
<td>@JsonCreator</td>
<td>用于构造方法，和 @JsonProperty 配合使用，适用有参数的构造方法。 示例： @JsonCreator public Person(@JsonProperty(“name”)String name) {…}</td>
</tr>
<tr>
<td>@JsonAnySetter</td>
<td>用于属性或者方法，设置未反序列化的属性名和值作为键值存储到 map 中 @JsonAnySetter public void set(String key, Object value) { map.put(key, value); }</td>
</tr>
<tr>
<td>@JsonIgnoreProperties</td>
<td>此注解是类注解，作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。 写法将此标签加在model 类的类名上 ，可以多个属性也可以单个属性</td>
</tr>
<tr>
<td>@JsonIgnore</td>
<td>用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。</td>
</tr>
<tr>
<td>@JsonSerialize</td>
<td>用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码，比如序列化一个double时在其后面限制两位小数点。</td>
</tr>
<tr>
<td>@JsonDeserialize</td>
<td>用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码，类似于上面的@JsonSerialize</td>
</tr>
<tr>
<td>@Transient</td>
<td>如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient，否则ORM框架默认其注解为@Basic；</td>
</tr>
</tbody></table>
<p>注： @JsonIgnore vs @Transient -difference?</p>
<img src="/2020/07/10/Jackson%E7%9A%84%E4%BD%BF%E7%94%A8/jack.png" class="" title="@JsonIgnore vs @Transient">

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.yiibai.com/jackson" target="_blank" rel="noopener">https://www.yiibai.com/jackson</a></p>
<p><a href="https://developer.ibm.com/zh/articles/jackson-advanced-application/" target="_blank" rel="noopener">https://developer.ibm.com/zh/articles/jackson-advanced-application/</a></p>
<p><a href="https://blog.csdn.net/u012373815/article/details/52266609" target="_blank" rel="noopener">https://blog.csdn.net/u012373815/article/details/52266609</a></p>
<p><a href="https://stackoverflow.com/questions/29762328/jsonignore-vs-transient-difference/29762521#29762521?newreg=585c962710714560b6c3079b4b37850a" target="_blank" rel="noopener">https://stackoverflow.com/questions/29762328/jsonignore-vs-transient-difference/29762521#29762521?newreg=585c962710714560b6c3079b4b37850a</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java使用easyexcel操作excel</title>
    <url>/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在工作中，使用excel表格处理数据是很常见的操作，本文就来讲解下如何使用开源轮子实现下载、导入、导出的功能。</p>
<p>在之前，很多Java程序员都喜欢使用POI的类库来操作excel,但是非常的不方便，不仅代码写的很臃肿，还要处理各种office版本兼容问题，最怕的就是使用不当很容易造成内存溢出，因此今天给大家推荐阿里的一款开源项目 <strong>easyexcel</strong>。</p>
<a id="more"></a>

<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>easyexcel是一款快速、简单避免OOM的java处理Excel工具</p>
<p>github地址:<a href="https://github.com/alibaba/easyexcel" target="_blank" rel="noopener">https://github.com/alibaba/easyexcel</a></p>
<p>Start:15.2k</p>
<p>看了下，两天前项目团队还有在完善代码，可见项目还是挺活跃的</p>
<h3 id="项目集成"><a href="#项目集成" class="headerlink" title="项目集成"></a>项目集成</h3><p>使用idea开发工具简单创建了一个easyexcel-demo项目，加入了web模块以及easyexcel maven依赖，依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;easyexcel --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easyexcel&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>好了，我们就开始写功能了。</p>
<h3 id="1、实现已有Excel模板下载"><a href="#1、实现已有Excel模板下载" class="headerlink" title="1、实现已有Excel模板下载"></a>1、实现已有Excel模板下载</h3><p>很多系统有数据批量导入的场景，因为在页面上批量加数据时间成本太大了，但是一般导入的时候得按照一定的格式改，所以一般好的产品会先让用户下载一个带有格式的文档，然后按照格式写好以后上传导入，我们来实现这个功能吧！</p>
<h4 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h4><p>首先我们创建一个模板文件，内容如图:</p>
<img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/excel_format.png" class="" title="excel表格样式">

<h4 id="将模板文件放置在项目里"><a href="#将模板文件放置在项目里" class="headerlink" title="将模板文件放置在项目里"></a>将模板文件放置在项目里</h4><p>然后我们把它放在项目的配置文件下，如图：</p>
<img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/excel_in_project.png" class="" title="excel在项目中的位置">

<p>然后下载代码也很简单，主要分为<strong>加载资源-&gt;读取资源-&gt;写入响应流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/downloadTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadTemplate</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathResource classPathResource = <span class="keyword">new</span> ClassPathResource(<span class="string">"excelTemplate/easyexcel.xls"</span>);</span><br><span class="line">        InputStream inputStream = classPathResource.getInputStream();</span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(inputStream);</span><br><span class="line">        response.setContentType(<span class="string">"application/vnd.ms-excel"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"content-Disposition"</span>, <span class="string">"attachment;filename="</span> + URLEncoder.encode(<span class="string">"easyexcel.xls"</span>, <span class="string">"utf-8"</span>));</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Expose-Headers"</span>, <span class="string">"content-Disposition"</span>);</span><br><span class="line">        OutputStream outputStream = response.getOutputStream();</span><br><span class="line">        workbook.write(outputStream);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>输入网址 <a href="http://localhost:8080/excel/downloadTemplate" target="_blank" rel="noopener">http://localhost:8080/excel/downloadTemplate</a> 进行测试：</p>
<img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/download_template.png" class="" title="测试下载模版">

<h3 id="2-写入数据并生成文件"><a href="#2-写入数据并生成文件" class="headerlink" title="2.写入数据并生成文件"></a>2.写入数据并生成文件</h3><p>将数据导出到文档这种场景可以说是最常见的了，那么怎么使用easyExcel快速实现呢，我们同样还是以上面的模板为例</p>
<h4 id="定义模型映射对象-UserExcelModel"><a href="#定义模型映射对象-UserExcelModel" class="headerlink" title="定义模型映射对象 UserExcelModel"></a>定义模型映射对象 UserExcelModel</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserExcelModel</span>  <span class="keyword">extends</span> <span class="title">BaseRowModel</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"用户名"</span>, index = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"年龄"</span>, index = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"手机号"</span>, index = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"性别"</span>, index = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserExcelModel</span><span class="params">(String name, Integer age, String mobile, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserExcelModel</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义这个对象的目的有两个：当前场景下写入文件作为model对象构造数据以及下个要讲的数据读取了。</p>
<p>「简要代码流程如下：」</p>
<p><strong>定义列标题-&gt;创建sheet-&gt;自定义字体和风格-&gt;构造数据-&gt;写入数据-&gt;写入到浏览器响应流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/exportData"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportData</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XSSFWorkbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line"></span><br><span class="line">        String []columnNames = &#123;<span class="string">"用户名"</span>,<span class="string">"年龄"</span>,<span class="string">"手机号"</span>,<span class="string">"性别"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Sheet sheet = workbook.createSheet();</span><br><span class="line">        Font titleFont = workbook.createFont();</span><br><span class="line">        titleFont.setFontName(<span class="string">"simsun"</span>);</span><br><span class="line">        titleFont.setBold(<span class="keyword">true</span>);</span><br><span class="line">        titleFont.setColor(IndexedColors.BLACK.index);</span><br><span class="line"></span><br><span class="line">        XSSFCellStyle titleStyle = workbook.createCellStyle();</span><br><span class="line">        titleStyle.setAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        titleStyle.setVerticalAlignment(VerticalAlignment.CENTER);</span><br><span class="line">        titleStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">        titleStyle.setFillForegroundColor(IndexedColors.YELLOW.index);</span><br><span class="line">        titleStyle.setFont(titleFont);</span><br><span class="line"></span><br><span class="line">        Row titleRow = sheet.createRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnNames.length; i++) &#123;</span><br><span class="line">            Cell cell = titleRow.createCell(i);</span><br><span class="line">            cell.setCellValue(columnNames[i]);</span><br><span class="line">            cell.setCellStyle(titleStyle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟构造数据</span></span><br><span class="line">        List&lt;UserExcelModel&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dataList.add(<span class="keyword">new</span> UserExcelModel(<span class="string">"张三"</span>,<span class="number">12</span>,<span class="string">"13867098765"</span>,<span class="string">"男"</span>));</span><br><span class="line">        dataList.add(<span class="keyword">new</span> UserExcelModel(<span class="string">"张三1"</span>,<span class="number">12</span>,<span class="string">"13867098765"</span>,<span class="string">"男"</span>));</span><br><span class="line">        dataList.add(<span class="keyword">new</span> UserExcelModel(<span class="string">"张三2"</span>,<span class="number">12</span>,<span class="string">"13867098765"</span>,<span class="string">"男"</span>));</span><br><span class="line">        dataList.add(<span class="keyword">new</span> UserExcelModel(<span class="string">"张三3"</span>,<span class="number">12</span>,<span class="string">"13867098765"</span>,<span class="string">"男"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数据行并写入值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dataList.size(); j++) &#123;</span><br><span class="line">            UserExcelModel userExcelModel = dataList.get(j);</span><br><span class="line">            <span class="keyword">int</span> lastRowNum = sheet.getLastRowNum();</span><br><span class="line">            Row dataRow = sheet.createRow(lastRowNum + <span class="number">1</span>);</span><br><span class="line">            dataRow.createCell(<span class="number">0</span>).setCellValue(userExcelModel.getName());</span><br><span class="line">            dataRow.createCell(<span class="number">1</span>).setCellValue(userExcelModel.getAge());</span><br><span class="line">            dataRow.createCell(<span class="number">2</span>).setCellValue(userExcelModel.getMobile());</span><br><span class="line">            dataRow.createCell(<span class="number">3</span>).setCellValue(userExcelModel.getSex());</span><br><span class="line">        &#125;</span><br><span class="line">        response.setContentType(<span class="string">"application/vnd.ms-excel"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"content-Disposition"</span>, <span class="string">"attachment;filename="</span> + URLEncoder.encode(<span class="string">"easyexcel.xls"</span>, <span class="string">"utf-8"</span>));</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Expose-Headers"</span>, <span class="string">"content-Disposition"</span>);</span><br><span class="line">        OutputStream outputStream = response.getOutputStream();</span><br><span class="line">        workbook.write(outputStream);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-读取数据"><a href="#3-读取数据" class="headerlink" title="3.读取数据"></a>3.读取数据</h3><p>我们再回过头来看我们定义的这个Model对象，通过指定index可以对应读取的excel里面的列，然后定义的数据类型就对应到excel里面具体的值，来看看如何实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/readExcel"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserExcelModel&gt; <span class="title">readExcel</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> MultipartFile file)</span>&#123;</span><br><span class="line">        List&lt;UserExcelModel&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list = EasyExcel.read(file.getInputStream(),UserExcelModel<span class="class">.<span class="keyword">class</span>,<span class="title">new</span> <span class="title">ModelExcelListener</span>()).<span class="title">sheet</span>().<span class="title">doReadSync</span>()</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看完代码是不是心里一万头草拟吗飞过~ 看完这个代码再看用poi工具处理的，是不是相当简洁了。对于代码中的ModelExcelListener,其实是我们自定义的一个读取监听类，贴贴代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelExcelListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Object&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过 AnalysisContext 对象还可以获取当前 sheet，当前行等数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//数据存储到list，供批量处理，或后续自己业务逻辑处理。</span></span><br><span class="line">            log.info(<span class="string">"读取到数据&#123;&#125;"</span>,data);</span><br><span class="line">            datas.add(data);</span><br><span class="line">            <span class="comment">//根据业务自行处理，可以写入数据库等等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所以的数据解析完了调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"所有数据解析完成"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个读取数据监听类，有特殊业务需求的都可以在这个类里面自定义实现，比如边读边写库啊，数据过滤和处理等等，用的好了绝对是一把利剑。</p>
<h4 id="postman模拟调用"><a href="#postman模拟调用" class="headerlink" title="postman模拟调用"></a>postman模拟调用</h4><img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/postman.png" class="" title="postman模拟调用">

<h4 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h4><img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/console.png" class="" title="控制台输出">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本篇文章，我们演示了如何使用easyexcel进行一些excel的操作，在实际的项目应用中，可以对以上示例代码进行进一步的封装，使其不管是读取、导出等操作都能几行代码搞定，这个就得根据情况大家自由发挥了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s/PyblQA4I9Wp9JT4ll2WcQA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PyblQA4I9Wp9JT4ll2WcQA</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java自定义注解</title>
    <url>/2020/05/03/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>最近看项目代码的时候看到了前辈们的写的自定义注解，决定深入的学习一下自定义注解相关的知识。</p>
<h2 id="1-注解知识介绍"><a href="#1-注解知识介绍" class="headerlink" title="1 注解知识介绍"></a>1 注解知识介绍</h2><h3 id="1-1-注解的定义"><a href="#1-1-注解的定义" class="headerlink" title="1.1 注解的定义"></a>1.1 注解的定义</h3><p>一般在项目中声明在annotation包中，声明用@interface表示</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BussinessLog &#123;</span><br><span class="line">	.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-元注解介绍"><a href="#1-2-元注解介绍" class="headerlink" title="1.2 元注解介绍"></a>1.2 元注解介绍</h3><p>元注解的作用就是负责注解其他注解。<br>常见的有四种注解：</p>
<h4 id="1-2-1-Inherited"><a href="#1-2-1-Inherited" class="headerlink" title="1.2.1 @Inherited"></a>1.2.1 @Inherited</h4><p> @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。<br> 比如，注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。</p>
<h4 id="1-2-2-Retention"><a href="#1-2-2-Retention" class="headerlink" title="1.2.2 @Retention"></a>1.2.2 @Retention</h4><p> 用来说明该注解类的生命周期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE) </span><br><span class="line"> <span class="comment">//注解只在源码阶段保留，在编译器完整编译之后，它将被丢弃忽视</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS) </span><br><span class="line"> <span class="comment">//默认，注解只被保留到编译进行的时候，它并不会被加载到 JVM 中</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  </span><br><span class="line"> <span class="comment">//注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们，大部分的注解都是 RUNTIME 的生命周期。</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-Target"><a href="#1-2-3-Target" class="headerlink" title="1.2.3 @Target"></a>1.2.3 @Target</h4><p> 表明注解的作用目标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)                          <span class="comment">// 接口、类、枚举、注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)                         <span class="comment">// 字段、枚举的常量</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)                        <span class="comment">// 方法</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)                     <span class="comment">// 方法参数</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.CONSTRUCTOR)                   <span class="comment">// 构造函数</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.LOCAL_VARIABLE)                <span class="comment">// 局部变量</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)               <span class="comment">// 注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PACKAGE)                       <span class="comment">// 包</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-Document"><a href="#1-2-4-Document" class="headerlink" title="1.2.4 @Document"></a>1.2.4 @Document</h4><p>@Documented 是一个简单的标记注解，表示是否将注解信息添加在 Java 文档，即 Javadoc 中。</p>
<h3 id="1-3-注解的属性"><a href="#1-3-注解的属性" class="headerlink" title="1.3 注解的属性"></a>1.3 注解的属性</h3><p>可以查看@RequestMapping的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的属性也叫做成员变量。注解只有<strong>成员变量</strong>，没有方法。注解的成员变量在注解的定义中以无形参的方法形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。<br>注解可以有默认值，需要用 <strong>default</strong> 关键字指定</p>
<h2 id="2-自定义注解示例"><a href="#2-自定义注解示例" class="headerlink" title="2 自定义注解示例"></a>2 自定义注解示例</h2><p>自定义@permission注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限注解 用于检查权限 规定访问权限</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span> <span class="doctag">@Permission</span>(&#123;role1,role2&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span> <span class="doctag">@Permission</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Permission &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;角色英文名称&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;使用注解时加上这个值表示限制只有某个角色的才可以访问对应的资源&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;常用在某些资源限制只有超级管理员角色才可访问&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-注解的使用"><a href="#3-注解的使用" class="headerlink" title="3 注解的使用"></a>3 注解的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Permission</span>(Const.ADMIN_NAME)</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/edit"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tip <span class="title">edit</span><span class="params">(BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GunsException(ExceptionEnum.REQUEST_NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.menuService.updateById(menu);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS_TIP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Java使用iTextPDF生成PDF文件</title>
    <url>/2020/07/01/Java%E4%BD%BF%E7%94%A8iTextPDF%E7%94%9F%E6%88%90PDF%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="iText介绍和说明"><a href="#iText介绍和说明" class="headerlink" title="iText介绍和说明"></a>iText介绍和说明</h2><p>因为项目需要生成PDF文件，所以去找了一下能够生成PDF的Java工具，看到了iText可以说好评如潮。</p>
<p>如果你想通过java操作PDF文件，那么 iText 绝对是你的首选。</p>
<a id="more"></a>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>这里使用的是iText5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.itextpdf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;itextpdf&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.10&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.itextpdf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;itext-asian&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用步骤简单介绍"><a href="#使用步骤简单介绍" class="headerlink" title="使用步骤简单介绍"></a>使用步骤简单介绍</h2><p>快速入手iText拢共需要5步：</p>
<ol>
<li><p>创建文档实例 Document</p>
</li>
<li><p>获取PdfWriter实例 （需要指定Document实例 和pdf 生成的磁盘路径）</p>
</li>
<li><p>打开文档</p>
</li>
<li><p>添加段落内容</p>
</li>
<li><p>关闭操作文档实例 （操作完成后必须执行文档关闭操作）</p>
</li>
</ol>
<h2 id="创建工具类"><a href="#创建工具类" class="headerlink" title="创建工具类"></a>创建工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标准字体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Font NORMALFONT;</span><br><span class="line">    <span class="comment">// 加粗字体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Font BOLDFONT;</span><br><span class="line">    <span class="comment">//固定高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> fixedHeight = <span class="number">27f</span>;</span><br><span class="line">    <span class="comment">//间距</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> spacing = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BaseFont bfChinese = BaseFont.createFont(<span class="string">"STSong-Light"</span>, <span class="string">"UniGB-UCS2-H"</span>, BaseFont.NOT_EMBEDDED);</span><br><span class="line">            NORMALFONT = <span class="keyword">new</span> Font(bfChinese, <span class="number">10</span>, Font.NORMAL);</span><br><span class="line">            BOLDFONT = <span class="keyword">new</span> Font(bfChinese, <span class="number">14</span>, Font.BOLD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">createDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成pdf</span></span><br><span class="line">        Document document = <span class="keyword">new</span> Document();</span><br><span class="line">        <span class="comment">// 页面大小</span></span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Rectangle(PageSize.A4);</span><br><span class="line">        <span class="comment">// 页面背景颜色</span></span><br><span class="line">        rectangle.setBackgroundColor(BaseColor.WHITE);</span><br><span class="line">        document.setPageSize(rectangle);</span><br><span class="line">        <span class="comment">// 页边距 左，右，上，下</span></span><br><span class="line">        document.setMargins(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> document;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 段落内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Paragraph <span class="title">createParagraph</span><span class="params">(String text, Font font)</span> </span>&#123;</span><br><span class="line">        Paragraph elements = <span class="keyword">new</span> Paragraph(text, font);</span><br><span class="line">        elements.setSpacingBefore(<span class="number">5</span>);</span><br><span class="line">        elements.setSpacingAfter(<span class="number">5</span>);</span><br><span class="line">        elements.setSpacingAfter(spacing);</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Font <span class="title">createFont</span><span class="params">(<span class="keyword">int</span> fontNumber, <span class="keyword">int</span> fontSize, BaseColor fontColor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中文字体 ----不然中文会乱码</span></span><br><span class="line">        BaseFont bf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bf = BaseFont.createFont(<span class="string">"STSong-Light"</span>, <span class="string">"UniGB-UCS2-H"</span>, BaseFont.NOT_EMBEDDED);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Font(bf, fontNumber, fontSize, fontColor);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Font(bf, Font.DEFAULTSIZE, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏表格边框线</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell 单元格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">disableBorderSide</span><span class="params">(PdfPCell cell)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cell.disableBorderSide(<span class="number">1</span>);</span><br><span class="line">            cell.disableBorderSide(<span class="number">2</span>);</span><br><span class="line">            cell.disableBorderSide(<span class="number">4</span>);</span><br><span class="line">            cell.disableBorderSide(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建居中得单元格</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PdfPCell <span class="title">createCenterPdfPCell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PdfPCell cell = <span class="keyword">new</span> PdfPCell();</span><br><span class="line">        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);</span><br><span class="line">        cell.setHorizontalAlignment(Element.ALIGN_CENTER);</span><br><span class="line">        cell.setFixedHeight(fixedHeight);</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定文字得单元格</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PdfPCell <span class="title">createCenterPdfPCell</span><span class="params">(String text, <span class="keyword">int</span> rowSpan, <span class="keyword">int</span> colSpan, Font font)</span> </span>&#123;</span><br><span class="line">        PdfPCell cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(text, font));</span><br><span class="line">        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);</span><br><span class="line">        cell.setHorizontalAlignment(Element.ALIGN_LEFT);</span><br><span class="line">        cell.setFixedHeight(fixedHeight);</span><br><span class="line">        cell.setRowspan(rowSpan);</span><br><span class="line">        cell.setColspan(colSpan);</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len 表格列数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PdfPTable <span class="title">createPdfPTable</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        PdfPTable pdfPTable = <span class="keyword">new</span> PdfPTable(len);</span><br><span class="line">        pdfPTable.setSpacingBefore(<span class="number">5</span>);</span><br><span class="line">        pdfPTable.setHorizontalAlignment(Element.ALIGN_CENTER);</span><br><span class="line">        <span class="keyword">return</span> pdfPTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建controller进行测试"><a href="#创建controller进行测试" class="headerlink" title="创建controller进行测试"></a>创建controller进行测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/28 3:17 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/pdf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/generate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">generatePDF</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String filename = <span class="string">"测试pdf"</span>;</span><br><span class="line">        <span class="comment">// 设置下载格式为pdf</span></span><br><span class="line">        response.setContentType(<span class="string">"application/x-download"</span>);</span><br><span class="line">        response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + URLEncoder.encode(filename, <span class="string">"UTF-8"</span>) + <span class="string">".pdf"</span>);</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> BufferedOutputStream(response.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Document document = new Document();</span></span><br><span class="line">        Document document = PdfUtil.createDocument();</span><br><span class="line">        <span class="comment">// 2. 获取writer</span></span><br><span class="line">        PdfWriter.getInstance(document, os);</span><br><span class="line">        <span class="comment">// 3. open()</span></span><br><span class="line">        document.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置字体</span></span><br><span class="line">        Font blackFont = PdfUtil.createFont(<span class="number">10</span>, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line">        Font blueFont = PdfUtil.createFont(<span class="number">10</span>, Font.NORMAL, BaseColor.BLUE);</span><br><span class="line">        Font bigFont = PdfUtil.createFont(<span class="number">14</span>, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line">        Font littleFont = PdfUtil.createFont(<span class="number">10</span>, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line"></span><br><span class="line">        Paragraph title = PdfUtil.createParagraph(<span class="string">"测试pdf"</span>, bigFont);</span><br><span class="line">        title.setAlignment(Element.ALIGN_CENTER);</span><br><span class="line">        <span class="comment">// 4. 添加段落内容</span></span><br><span class="line">        document.add(title);</span><br><span class="line">        <span class="comment">// 5. close()</span></span><br><span class="line">        document.close();</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response().setContent(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>下载页面：</p>
<img src="/2020/07/01/Java%E4%BD%BF%E7%94%A8iTextPDF%E7%94%9F%E6%88%90PDF%E6%96%87%E4%BB%B6/download_interface.png" class="" title="download_interface">

<p>下载的文件效果：</p>
<img src="/2020/07/01/Java%E4%BD%BF%E7%94%A8iTextPDF%E7%94%9F%E6%88%90PDF%E6%96%87%E4%BB%B6/download_file.png" class="" title="download_file">]]></content>
  </entry>
  <entry>
    <title>Java编写单词小游戏</title>
    <url>/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>公司最近有一个竞技场项目，里面有一个单词小游戏。</p>
<p>游戏大概就是随机生成一个5*5的棋盘，上面有单词的字母，通过滑动连出正确的单词。</p>
<a id="more"></a>

<h2 id="棋盘生成算法"><a href="#棋盘生成算法" class="headerlink" title="棋盘生成算法"></a>棋盘生成算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先随机选个一个起点，从这个点开始铺单词。</p>
<p>分别选取上下左右四个方向作为下一个字母的摆放位置，不能触边也不能走重复路，直到平铺完所有的单词。</p>
<p>如果在棋盘能平铺下单词的情况下，找不到路径，就从四个角作为起点，必能找到路径。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/31 5:50 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateWordBoard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenerateWordBoard g = <span class="keyword">new</span> GenerateWordBoard();</span><br><span class="line">        g.generateCharBoard(<span class="string">"vocabulary"</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateCharBoard</span><span class="params">(String word, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单词为空 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (word.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单词长度大于棋盘 铺不下 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt; m * n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化棋盘 全为*</span></span><br><span class="line">        initBoard(m, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] wordChar = word.toCharArray();</span><br><span class="line">        <span class="comment">// 随机选取一个位置开始</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomX = random.nextInt(m);</span><br><span class="line">        <span class="keyword">int</span> randomY = random.nextInt(n);</span><br><span class="line">        <span class="comment">// 开始从随机位置dfs铺单词 从index 0 开始</span></span><br><span class="line">        <span class="keyword">boolean</span> result = generateDfs(board, wordChar, randomX, randomY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果没有找到路线 那么从四个角开始 必能找到一条路</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; starts = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, n - <span class="number">1</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m - <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m - <span class="number">1</span>, n - <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="comment">// 随机四个角的一个</span></span><br><span class="line">            Collections.shuffle(starts);</span><br><span class="line">            <span class="comment">// 初始化棋盘</span></span><br><span class="line">            initBoard(m, n);</span><br><span class="line">            <span class="comment">// dfs铺单词</span></span><br><span class="line">            generateDfs(board, wordChar, starts.get(<span class="number">0</span>)[<span class="number">0</span>], starts.get(<span class="number">0</span>)[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(board[i][j] + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBoard</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        board = <span class="keyword">new</span> <span class="keyword">char</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'*'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回true则为找到一条路 返回false为死路</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">generateDfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] wordChar, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 碰到边 或者碰到已经走过的位置 不能走了 死路</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 摆放一个字母</span></span><br><span class="line">        board[i][j] = wordChar[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果已经达到单词长度则直接返回 找到一条路</span></span><br><span class="line">        <span class="keyword">if</span> (index == wordChar.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前矩阵元素</span></span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        <span class="comment">// 修改为/ 表示已经访问过</span></span><br><span class="line">        board[i][j] = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上下左右四个方向开启递归</span></span><br><span class="line">        <span class="comment">// 查看能走几个方向 随机选择一个</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; directions = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        Collections.shuffle(directions);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; directions.size(); k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> di = i + directions.get(k)[<span class="number">0</span>], dj = j + directions.get(k)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">boolean</span> partialRes = generateDfs(board, wordChar, di, dj, index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                res = partialRes;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = res || partialRes;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果res为true 说明找到一条路 就不再遍历了 还原后返回true</span></span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                <span class="comment">// 还原矩阵元素</span></span><br><span class="line">                board[i][j] = tmp;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还原矩阵元素</span></span><br><span class="line">        board[i][j] = <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><div style="display: flex;flex-direction: row;justify-content: center;">

<div style="width: 200px;height: 200px;"><img src="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/result1.png" class="" title="result1"></div>

<div style="width: 200px;height: 200px;"><img src="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/result2.png" class="" title="result2"></div>

<div style="width: 200px;height: 200px;"><img src="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/result3.png" class="" title="result3"></div>

<div style="width: 200px;height: 200px;"><img src="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/result4.png" class="" title="result4"></div>

</div>]]></content>
  </entry>
  <entry>
    <title>Java异常处理的十条建议</title>
    <url>/2020/06/15/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E6%9D%A1%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java异常处理的十个建议，希望对大家有帮助~</p>
<h3 id="一、尽量不要使用e-printStackTrace-而是使用log打印。"><a href="#一、尽量不要使用e-printStackTrace-而是使用log打印。" class="headerlink" title="一、尽量不要使用e.printStackTrace(),而是使用log打印。"></a>一、尽量不要使用e.printStackTrace(),而是使用log打印。</h3><p><strong>反例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  &#x2F;&#x2F; do what you want  </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  &#x2F;&#x2F; do what you want  </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  log.info(&quot;你的程序有异常啦,&#123;&#125;&quot;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。</li>
<li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了,即内存满了，那么，用户的请求就卡住啦~</li>
</ul>
<h3 id="二、catch了异常，但是没有打印出具体的exception，无法更好定位问题"><a href="#二、catch了异常，但是没有打印出具体的exception，无法更好定位问题" class="headerlink" title="二、catch了异常，但是没有打印出具体的exception，无法更好定位问题"></a>二、catch了异常，但是没有打印出具体的exception，无法更好定位问题</h3><p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  &#x2F;&#x2F; do what you want  </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  log.info(&quot;你的程序有异常啦&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  &#x2F;&#x2F; do what you want  </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  log.info(&quot;你的程序有异常啦，&#123;&#125;&quot;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>反例中，并没有把exception出来，到时候排查问题就不好查了啦，到底是SQl写错的异常还是IO异常，还是其他呢？所以应该把exception打印到日志中哦~</li>
</ul>
<h3 id="三、不要用一个Exception捕捉所有可能的异常"><a href="#三、不要用一个Exception捕捉所有可能的异常" class="headerlink" title="三、不要用一个Exception捕捉所有可能的异常"></a>三、不要用一个Exception捕捉所有可能的异常</h3><p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;…抛出 IOException 的代码调用</span><br><span class="line">        &#x2F;&#x2F;…抛出 SQLException 的代码调用</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        &#x2F;&#x2F;用基类 Exception 捕捉的所有可能的异常，如果多个层次都这样捕捉，会丢失原始异常的有效信息哦</span><br><span class="line">        log.info(“Exception in test,exception:&#123;&#125;”, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;…抛出 IOException 的代码调用</span><br><span class="line">        &#x2F;&#x2F;…抛出 SQLException 的代码调用</span><br><span class="line">    &#125;catch(IOException e)&#123;</span><br><span class="line">        &#x2F;&#x2F;仅仅捕捉 IOException</span><br><span class="line">        log.info(“IOException in test,exception:&#123;&#125;”, e);</span><br><span class="line">    &#125;catch(SQLException e)&#123;</span><br><span class="line">        &#x2F;&#x2F;仅仅捕捉 SQLException</span><br><span class="line">        log.info(“SQLException in test,exception:&#123;&#125;”, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理由：</p>
<ul>
<li>用基类 Exception 捕捉的所有可能的异常，如果多个层次都这样捕捉，会丢失原始异常的有效信息哦</li>
</ul>
<h3 id="四、记得使用finally关闭流资源或者直接使用try-with-resource"><a href="#四、记得使用finally关闭流资源或者直接使用try-with-resource" class="headerlink" title="四、记得使用finally关闭流资源或者直接使用try-with-resource"></a>四、记得使用finally关闭流资源或者直接使用try-with-resource</h3><p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileInputStream fdIn &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    fdIn &#x3D; new FileInputStream(new File(&quot;&#x2F;jay.txt&quot;));</span><br><span class="line">    &#x2F;&#x2F;在这里关闭流资源？有没有问题呢？如果发生异常了呢？</span><br><span class="line">    fdIn.close();</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例1：</strong></p>
<p>需要使用finally关闭流资源，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileInputStream fdIn &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    fdIn &#x3D; new FileInputStream(new File(&quot;&#x2F;jay.txt&quot;));</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fdIn !&#x3D; null) &#123;</span><br><span class="line">            fdIn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例2：</strong></p>
<p>当然，也可以使用JDK7的新特性try-with-resource来处理，它是Java7提供的一个新功能，它用于自动资源管理。</p>
<ul>
<li>资源是指在程序用完了之后必须要关闭的对象。</li>
<li>try-with-resources保证了每个声明了的资源在语句结束的时候会被关闭</li>
<li>什么样的对象才能当做资源使用呢？只要实现了java.lang.AutoCloseable接口或者java.io.Closeable接口的对象，都OK。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (FileInputStream inputStream &#x3D; new FileInputStream(new File(&quot;jay.txt&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; use resources   </span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理由：</strong></p>
<ul>
<li>如果不使用finally或者try-with-resource，当程序发生异常，IO资源流没关闭，那么这个IO资源就会被他一直占着，这样别人就没有办法用了，这就造成资源浪费。</li>
</ul>
<h3 id="五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类"><a href="#五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类" class="headerlink" title="五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类"></a>五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类</h3><p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;BizException 是 Exception 的子类</span><br><span class="line">public class BizException extends Exception &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;抛出父类Exception</span><br><span class="line">public static void test() throws Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    test(); &#x2F;&#x2F;编译错误</span><br><span class="line">&#125; catch (BizException e) &#123; &#x2F;&#x2F;捕获异常子类是没法匹配的哦</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抛出子类Exception</span><br><span class="line">public static void test() throws BizException &#123;&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、捕获到的异常，不能忽略它，至少打点日志吧"><a href="#六、捕获到的异常，不能忽略它，至少打点日志吧" class="headerlink" title="六、捕获到的异常，不能忽略它，至少打点日志吧"></a>六、捕获到的异常，不能忽略它，至少打点日志吧</h3><p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void testIgnoreException() throws Exception &#123;</span><br><span class="line">    try &#123;       </span><br><span class="line">        &#x2F;&#x2F; 搞事情</span><br><span class="line">    &#125; catch (Exception e) &#123;     &#x2F;&#x2F;一般不会有这个异常</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void testIgnoreException() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 搞事情</span><br><span class="line">    &#125; catch (Exception e) &#123;     &#x2F;&#x2F;一般不会有这个异常</span><br><span class="line">        log.error(&quot;这个异常不应该在这里出现的,&#123;&#125;&quot;,e); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理由：</strong></p>
<ul>
<li>虽然一个正常情况都不会发生的异常，但是如果你捕获到它，就不要忽略呀，至少打个日志吧~</li>
</ul>
<h3 id="七、注意异常对你的代码层次结构的侵染（早发现早处理）"><a href="#七、注意异常对你的代码层次结构的侵染（早发现早处理）" class="headerlink" title="七、注意异常对你的代码层次结构的侵染（早发现早处理）"></a>七、注意异常对你的代码层次结构的侵染（早发现早处理）</h3><p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public UserInfo queryUserInfoByUserId(Long userid) throw SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F;根据用户Id查询数据库</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public UserInfo queryUserInfoByUserId(Long userid) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;根据用户Id查询数据库</span><br><span class="line">    &#125;catch(SQLException e)&#123;</span><br><span class="line">        log.error(&quot;查询数据库异常啦，&#123;&#125;&quot;,e);</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        &#x2F;&#x2F;关闭连接，清理资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>我们的项目，一般都会把代码分 Action、Service、Dao 等不同的层次结构，如果你是DAO层处理的异常，尽早处理吧，如果往上 throw SQLException，上层代码就还是要try catch处理啦，这就污染了你的代码~</li>
</ul>
<h3 id="八、自定义封装异常，不要丢弃原始异常的信息Throwable-cause"><a href="#八、自定义封装异常，不要丢弃原始异常的信息Throwable-cause" class="headerlink" title="八、自定义封装异常，不要丢弃原始异常的信息Throwable cause"></a>八、自定义封装异常，不要丢弃原始异常的信息Throwable cause</h3><p>我们常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。公司的框架提供统一异常处理就用到异常链，我们自定义封装异常，不要丢弃原始异常的信息，否则排查问题就头疼啦</p>
<p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestChainException &#123;</span><br><span class="line">    public void readFile() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream is &#x3D; new FileInputStream(&quot;jay.txt&quot;);</span><br><span class="line">            Scanner in &#x3D; new Scanner(is);</span><br><span class="line">            while (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;e 保存异常信息</span><br><span class="line">            throw new MyException(&quot;文件在哪里呢&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void invokeReadFile() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            readFile();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;e 保存异常信息</span><br><span class="line">            throw new MyException(&quot;文件找不到&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestChainException t &#x3D; new TestChainException();</span><br><span class="line">        try &#123;</span><br><span class="line">            t.invokeReadFile();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;MyException 构造器</span><br><span class="line">public MyException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下，没有了Throwable cause，不好排查是什么异常了啦</p>
<img src="/2020/06/15/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E6%9D%A1%E5%BB%BA%E8%AE%AE/exception1.png" class="" title="exception before">

<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class TestChainException &#123;</span><br><span class="line">    public void readFile() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream is &#x3D; new FileInputStream(&quot;jay.txt&quot;);</span><br><span class="line">            Scanner in &#x3D; new Scanner(is);</span><br><span class="line">            while (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;e 保存异常信息</span><br><span class="line">            throw new MyException(&quot;文件在哪里呢&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void invokeReadFile() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            readFile();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;e 保存异常信息</span><br><span class="line">            throw new MyException(&quot;文件找不到&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestChainException t &#x3D; new TestChainException();</span><br><span class="line">        try &#123;</span><br><span class="line">            t.invokeReadFile();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;MyException 构造器</span><br><span class="line">public MyException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/15/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E6%9D%A1%E5%BB%BA%E8%AE%AE/exception2.png" class="" title="exception after">


<h3 id="九、运行时异常RuntimeException-，不应该通过catch-的方式来处理，而是先预检查，比如：NullPointerException处理"><a href="#九、运行时异常RuntimeException-，不应该通过catch-的方式来处理，而是先预检查，比如：NullPointerException处理" class="headerlink" title="九、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理"></a>九、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理</h3><p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  obj.method() </span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (obj !&#x3D; null)&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十、注意异常匹配的顺序，优先捕获具体的异常"><a href="#十、注意异常匹配的顺序，优先捕获具体的异常" class="headerlink" title="十、注意异常匹配的顺序，优先捕获具体的异常"></a>十、注意异常匹配的顺序，优先捕获具体的异常</h3><p>注意异常的匹配顺序，因为只有第一个匹配到异常的catch块才会被执行。如果你希望看到，是NumberFormatException异常，就抛出NumberFormatException，如果是IllegalArgumentException就抛出IllegalArgumentException。</p>
<p><strong>反例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    doSomething(&quot;test exception&quot;);</span><br><span class="line">&#125; catch (IllegalArgumentException e) &#123;       </span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    doSomething(&quot;test exception&quot;);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;       </span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>因为NumberFormatException是IllegalArgumentException 的子类，反例中，不管是哪个异常，都会匹配到IllegalArgumentException，就不会再往下执行啦，因此不知道是否是NumberFormatException。所以需要优先捕获具体的异常，把NumberFormatException放前面~</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5ee45107f265da770952788f" target="_blank" rel="noopener">https://juejin.im/post/5ee45107f265da770952788f</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java面试常见问题-1</title>
    <url>/2020/05/04/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/</url>
    <content><![CDATA[<h2 id="1-String-StringBuilder-StringBuffer区别"><a href="#1-String-StringBuilder-StringBuffer区别" class="headerlink" title="1. String, StringBuilder, StringBuffer区别"></a>1. String, StringBuilder, StringBuffer区别</h2><p>这三个类的主要区别在两个方面：<strong>运算速度</strong>（运算性能或执行效率）和<strong>线程安全性</strong>。</p>
<h3 id="1-运算速度比较（通常情况下）：StringBuilder-gt-StringBuffer-gt-String"><a href="#1-运算速度比较（通常情况下）：StringBuilder-gt-StringBuffer-gt-String" class="headerlink" title="1. 运算速度比较（通常情况下）：StringBuilder &gt; StringBuffer &gt; String"></a>1. <strong>运算速度</strong>比较（通常情况下）：<strong>StringBuilder &gt; StringBuffer &gt; String</strong></h3><a id="more"></a>

<p>String是<strong>final</strong>类不能被继承且为字符串常量，而StringBuilder和StringBuffer均为<strong>字符串变量</strong>。String对象一旦创建便<strong>不可更改</strong>，而后两者是<strong>可更改</strong>的，它们只能通过构造函数来建立对象，且对象被建立以后将在内存中分配内存空间，并初始保存一个null，通过append方法向StringBuffer和StringBuilder中赋值。</p>
<p>Java中对String对象进行的操作实际上是一个不断创建并回收对象的过程，因此在运行速度上很慢。</p>
<h3 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2. 线程安全性"></a>2. 线程安全性</h3><p>StringBuilder（<strong>非线程安全</strong>）</p>
<p>而StringBuilder的方法没有该关键字修饰，所以不能保证线程安全性。</p>
<p>StringBuffer（<strong>线程安全的</strong>）</p>
<p>StringBuffer中大部分方法由<strong>synchronized</strong>关键字修饰，在必要时可对方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致，所以是线程安全的。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>String：适用于<strong>少量</strong>的字符串操作。</p>
<p>StringBuilder：适用于<strong>单线程</strong>下在字符串缓冲区进行大量操作。</p>
<p>StringBuffer：适用于<strong>多线程</strong>下在字符串缓冲区进行大量操作。</p>
<h2 id="2-Spring-Bean为什么是单例"><a href="#2-Spring-Bean为什么是单例" class="headerlink" title="2. Spring Bean为什么是单例"></a>2. Spring Bean为什么是单例</h2><h3 id="单例bean与原型bean的区别"><a href="#单例bean与原型bean的区别" class="headerlink" title="单例bean与原型bean的区别"></a>单例bean与原型bean的区别</h3><p><strong>单例：</strong>一个bean被声明为单例时，处理多次请求时spring容器里只实例化一个bean，后续的请求公用这个对象，这个对象存储在一个map中，当有请求时，先在缓存中（map）查找是否存在，存在则使用，不存在才实例化一个对象</p>
<p><strong>原型：</strong>每当有请求来就实例化一个新的bean，没有缓存以及从缓存中查</p>
<h4 id="单例bean的优势"><a href="#单例bean的优势" class="headerlink" title="单例bean的优势"></a>单例bean的优势</h4><p>由于不会每次都新创建新对象所以有一下几个性能上的优势：</p>
<p><strong>减少了新生成实例的消耗</strong></p>
<p>新生成实例消耗包括两方面，第一，spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。</p>
<p><strong>减少jvm垃圾回收</strong></p>
<p>由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。</p>
<p><strong>可以快速获取到bean</strong></p>
<p>因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。</p>
<h3 id="单例bean的劣势"><a href="#单例bean的劣势" class="headerlink" title="单例bean的劣势"></a>单例bean的劣势</h3><p>单例的bean一个很大的劣势就是他不能做到线程安全，由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试题：Spring 为啥把bean默认设计成单例？</p>
<p>答案：</p>
<p>为了提高性能<br>少创建实例<br>垃圾回收<br>缓存快速获取</p>
<p>单例有啥劣势？</p>
<p>如果是有状态的话在并发环境下线程不安全。</p>
<h2 id="3-项目中有用到多线程嘛"><a href="#3-项目中有用到多线程嘛" class="headerlink" title="3. 项目中有用到多线程嘛"></a>3. 项目中有用到多线程嘛</h2><p>用户注册完成送大礼包/积分之类，且积分等也是另一个系统并<strong>比较耗时</strong>；且这类任务即使失败也不是特别重要的。</p>
<p>后台线程：比如<strong>定期执行</strong>一些特殊任务，如定期更新配置文件，任务调度（如quartz），一些监控用于定期信息采集等。</p>
<p>特别耗时的操作，如备份数据库，可以开个线程执行备份，然后执行返回，前台不断向后台询问线程执行状态</p>
<p>场景一:一个业务逻辑有很多次的循环，<strong>每次循环之间没有影响</strong>，比如验证1万条url路径是否存在，正常情况要循环1万次，逐个去验证每一条URL，这样效率会很低，假设验证一条需要1分钟，总共就需要1万分钟，有点恐怖。这时可以用多线程，将1万条URL分成50等份，开50个线程，没个线程只需验证200条，这样所有的线程执行完是远小于1万分钟的。</p>
<p>场景二:需要知道一个任务的执行进度，比如我们常看到的进度条，实现方式可以是在任务中加入一个整型属性变量(这样不同方法可以共享)，任务执行一定程度就给变量值加1，另外开一个线程按时间间隔不断去访问这个变量，并反馈给用户。</p>
<p>总之<strong>使用多线程就是为了充分利用cpu的资源，提高程序执行效率</strong>，当你发现一个业务逻辑执行效率特别低，耗时特别长，就可以考虑使用多线程。<strong>不过CPU执行哪个线程的时间和顺序是不确定的</strong>，即使设置了线程的优先级，因此使用多线程的风险也是比较大的，会出现很多预料不到的问题，一定要多熟悉概念，多构造不同的场景去测试才能够掌握!</p>
<h2 id="4-HashMap为什么要重写hashCode和equals方法"><a href="#4-HashMap为什么要重写hashCode和equals方法" class="headerlink" title="4. HashMap为什么要重写hashCode和equals方法"></a>4. HashMap为什么要重写hashCode和equals方法</h2><p>HashMap和Hashtable的底层实现都是数组+链表结构实现的</p>
<p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。</p>
<p>如果你重载了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。</p>
<p>这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。</p>
<p>对于每一个对象，通过其hashCode()方法可为其生成一个整形值（散列码），该整型值被处理后，将会作为数组下标，存放该对象所对应的Entry（存放该对象及其对应值）。 </p>
<p>equals()方法则是在HashMap中插入值或查询时会使用到。当HashMap中插入值或查询值对应的散列码与数组中的散列码相等时，则会通过equals方法比较key值是否相等</p>
<p>所以想以自建对象作为HashMap的key，必须重写该对象继承object的hashCode和equals方法。</p>
<h2 id="5-Java集合中为什么要使用设计迭代器"><a href="#5-Java集合中为什么要使用设计迭代器" class="headerlink" title="5. Java集合中为什么要使用设计迭代器"></a>5. Java集合中为什么要使用设计迭代器</h2><p>优点: </p>
<pre><code>1. 可以不了解集合内部的数据结构,就可以直接遍历;

2. **不暴露内部的数据**,可以直接外部遍历;

3. 适用性强,基本上的集合都能使用迭代器;</code></pre><h2 id="6-为什么使用迭代器遍历删除是安全的"><a href="#6-为什么使用迭代器遍历删除是安全的" class="headerlink" title="6. 为什么使用迭代器遍历删除是安全的"></a>6. 为什么使用迭代器遍历删除是安全的</h2><p>基本上<strong>ArrayList采用size属性来维护自已的状态，而Iterator采用cursor来来维护自已的状态</strong>。</p>
<p>当size出现变化时，cursor并不一定能够得到同步，除非这种变化是Iterator主动导致的。</p>
<p>当Iterator.remove方法导致ArrayList列表发生变化时，他会更新cursor来同步这一变化。但其他方式导致的ArrayList变化，Iterator是无法感知的。ArrayList自然也不会主动通知Iterator们，那将是一个繁重的工作。Iterator到底还是做了努力：为了防止状态不一致可能引发的无法设想的后果，Iterator会经常做checkForComodification检查，以防有变。如果有变，则以异常抛出，所以就出现了上面的异常。</p>
<h2 id="7-Spring事务传播机制"><a href="#7-Spring事务传播机制" class="headerlink" title="7. Spring事务传播机制"></a>7. Spring事务传播机制</h2><ul>
<li>@Transactional(propagation=Propagation.REQUIRED)<br>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)</li>
<li>@Transactional(propagation=Propagation.NOT_SUPPORTED)<br>容器不为这个方法开启事务</li>
<li>@Transactional(propagation=Propagation.REQUIRES_NEW)<br>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务</li>
<li>@Transactional(propagation=Propagation.MANDATORY)<br>必须在一个已有的事务中执行,否则抛出异常</li>
<li>@Transactional(propagation=Propagation.NEVER)<br>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)</li>
<li>@Transactional(propagation=Propagation.SUPPORTS)<br>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java面试常见问题-2</title>
    <url>/2020/05/08/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2/</url>
    <content><![CDATA[<h3 id="搜索引擎的工作原理"><a href="#搜索引擎的工作原理" class="headerlink" title="搜索引擎的工作原理"></a>搜索引擎的工作原理</h3><p>各个搜索引擎都有叫做“蜘蛛”的机器人，这些机器人负责在网络上收集网站上的各种各样的信息。</p>
<p>每个网站都有非常多的链接，有的是链接到网站内容页面的，有的是链接到其他网站的，搜索引擎的蜘蛛就会顺着这些链接爬下去，把符合标准的网页搬回自己的数据库，这也就是搜索引擎能给我们提供成千上万个结果的原因了。</p>
<p>这就完成了第一部分的工作，这又怎么样快速的从搜索引擎中找到我们想要的东西呢？</p>
<a id="more"></a>

<p>第二步就是建立索引，这个就像是书的目录一样。一般来讲，搜索引擎会分析网页的关键词，有关键字的并且出现多次的在结果中就会比较靠前。然后这个网站是不是一个人气高的网站，打开速度快不快等等，各种各样的因素都会影响搜索引擎给网站的评分，从而影响网站在搜索结果中的排名。</p>
<p>这就是搜索引擎大概的工作原理。</p>
<h3 id="JDK和JRE的区别是什么"><a href="#JDK和JRE的区别是什么" class="headerlink" title="JDK和JRE的区别是什么"></a>JDK和JRE的区别是什么</h3><p>JDK: <strong>java开发工具包</strong>,包含了JRE、编译器和其它工具（如：javaDoc、java调试器)</p>
<p>JRE: <strong>java运行环境</strong>,包含java虚拟机和java程序所需的核心类库。</p>
<p>如果只是想跑java程序，那么只需安装JRE，如果要写java程序并且运行，那就需要JDK了。</p>
<h3 id="Java支持多继承么？如果不支持，如何实现"><a href="#Java支持多继承么？如果不支持，如何实现" class="headerlink" title="Java支持多继承么？如果不支持，如何实现?"></a>Java支持多继承么？如果不支持，如何实现?</h3><p>在java中是单继承的，也就是说一个类只能继承一个父类。</p>
<p>java中实现多继承有两种方式,一是<strong>接口</strong>，而是<strong>内部类</strong>.</p>
<h3 id="JVM内存分哪几个区，每个区的作用是什么"><a href="#JVM内存分哪几个区，每个区的作用是什么" class="headerlink" title="JVM内存分哪几个区，每个区的作用是什么?"></a>JVM内存分哪几个区，每个区的作用是什么?</h3><p>java虚拟机主要分为以下几个区:</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载</p>
<p><strong>方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</strong></p>
<p>该区域是被线程共享的。</p>
<p>方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p><strong>虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</strong></p>
<p>虚拟机栈是线程私有的，它的生命周期与线程相同。</p>
<p>局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p>
<p>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈和虚拟机栈类似，只不过<strong>本地方法栈为Native方法服务</strong>。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>java堆是所有线程所共享的一块内存，在虚拟机启动时创建，<strong>几乎所有的对象实例都在这里创建</strong>，因此该区域经常发生垃圾回收操作。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><strong>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。</strong>该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>java内存模型(JMM)是线程间通信的控制机制.<strong>JMM定义了主内存和线程之间抽象关系</strong>。</p>
<p>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<img src="/2020/05/08/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" class="" title="Java内存模型">
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<p>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</p>
<p>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</p>
<h3 id="简述java垃圾回收机制"><a href="#简述java垃圾回收机制" class="headerlink" title="简述java垃圾回收机制?"></a>简述java垃圾回收机制?</h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h3 id="java中垃圾收集的方法有哪些"><a href="#java中垃圾收集的方法有哪些" class="headerlink" title="java中垃圾收集的方法有哪些?"></a>java中垃圾收集的方法有哪些?</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除:"></a>标记-清除:</h4><p>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法:"></a>复制算法:</h4><p>为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。</p>
<p>于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)</p>
<h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理:"></a>标记-整理:</h4><p>该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</p>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集:"></a>分代收集:</h4><p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
<h3 id="类加载器双亲委派模型机制？"><a href="#类加载器双亲委派模型机制？" class="headerlink" title="类加载器双亲委派模型机制？"></a>类加载器双亲委派模型机制？</h3><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>
<h3 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h3><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p>
<p>主要有一下四种类加载器:</p>
<p><strong>启动类加载器</strong>(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。<br><strong>扩展类加载器</strong>(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br><strong>系统类加载器</strong>（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。<br><strong>用户自定义类加载器</strong>，通过继承 java.lang.ClassLoader类的方式实现。</p>
<h3 id="HashMap的工作原理是什么"><a href="#HashMap的工作原理是什么" class="headerlink" title="HashMap的工作原理是什么?"></a>HashMap的工作原理是什么?</h3><p>HashMap内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个Entry实体(jdk 8为Node)，这个Entry实体主要包含key、value以及一个指向自身的next指针。</p>
<p>HashMap是基于hashing实现的，当我们进行put操作时，根据传递的key值得到它的hashcode，然后再用这个hashcode与数组的长度进行模运算，得到一个int值，就是Entry要存储在数组的位置（下标）；</p>
<p>当通过get方法获取指定key的值时，会根据这个key算出它的hash值（数组下标），根据这个hash值获取数组下标对应的Entry，然后判断Entry里的key，hash值或者通过equals()比较是否与要查找的相同，如果相同，返回value，否则的话，遍历该链表（有可能就只有一个Entry，此时直接返回null），直到找到为止，否则返回null。</p>
<p>HashMap之所以在每个数组元素存储的是一个链表，是为了解决hash冲突问题，当两个对象的hash值相等时，那么一个位置肯定是放不下两个值的，于是hashmap采用链表来解决这种冲突，hash值相等的两个元素会形成一个链表。</p>
<h3 id="CorrentHashMap的工作原理"><a href="#CorrentHashMap的工作原理" class="headerlink" title="CorrentHashMap的工作原理?"></a>CorrentHashMap的工作原理?</h3><p>jdk 1.6版: ConcurrenHashMap可以说是HashMap的升级版，ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。</p>
<p>具体实现:ConcurrentHashMap内部有一个Segment&lt;K,V&gt;数组,该Segment对象可以充当锁。Segment对象内部有一个HashEntry&lt;K,V&gt;数组，于是每个Segment可以守护若干个桶(HashEntry),每个桶又有可能是一个HashEntry连接起来的链表，存储发生碰撞的元素。</p>
<p>每个ConcurrentHashMap在默认并发级下会创建包含16个Segment对象的数组，每个数组有若干个桶，当我们进行put方法时，通过hash方法对key进行计算，得到hash值，找到对应的segment，然后对该segment进行加锁，然后调用segment的put方法进行存储操作，此时其他线程就不能访问当前的segment，但可以访问其他的segment对象，不会发生阻塞等待。</p>
<p>jdk 1.8版 在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p>
<h3 id="fail-fast与fail-safe有什么区别？"><a href="#fail-fast与fail-safe有什么区别？" class="headerlink" title="fail-fast与fail-safe有什么区别？"></a>fail-fast与fail-safe有什么区别？</h3><p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。</p>
<p>Java.util包中的所有集合类都被设计为fail-&gt;fast的，而java.util.concurrent中的集合类都为fail-safe的。</p>
<p>当检测到正在遍历的集合的结构被改变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p>
<h3 id="RandomAccess是什么？"><a href="#RandomAccess是什么？" class="headerlink" title="RandomAccess是什么？"></a>RandomAccess是什么？</h3><p>RandomAccess接口是一个标记接口，用以标记实现的List集合具备快速随机访问的能力。</p>
<p>那么什么是随机访问的能力呢？其实很简单，随机访问就是随机的访问List中的任何一个元素。</p>
<p>ArrayList实现了RandomAccess接口，而LinkedList没有。</p>
<p>那么到底这个接口有什么用呢？</p>
<p><strong>当一个List拥有快速访问功能时，其遍历方法采用for循环最快速。而没有快速访问功能的List，遍历的时候采用Iterator迭代器最快速。</strong></p>
<p>当我们不明确获取到的是Arraylist，还是LinkedList的时候，我们可以通过RandomAccess来判断其是否支持快速随机访问，若支持则采用for循环遍历，否则采用迭代器遍历，</p>
<p>那么都有哪些类实现了这个接口呢？</p>
<ul>
<li>ArrayList</li>
<li>Vector</li>
<li>CopyOnWriteArrayList</li>
<li>RandomAccessSubList</li>
<li>UnmodifiableArrayList</li>
</ul>
<h3 id="HashSet的底层实现是什么"><a href="#HashSet的底层实现是什么" class="headerlink" title="HashSet的底层实现是什么?"></a>HashSet的底层实现是什么?</h3><p>通过看源码知道HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。</p>
<h3 id="LinkedHashMap的实现原理"><a href="#LinkedHashMap的实现原理" class="headerlink" title="LinkedHashMap的实现原理?"></a>LinkedHashMap的实现原理?</h3><p>LinkedHashMap也是基于HashMap实现的，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p>
<h3 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run() 方法有什么区别？"></a>Thread 类中的start() 和 run() 方法有什么区别？</h3><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h3 id="为什么wait-notify-和-notifyAll这些方法不在thread类里面"><a href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在thread类里面?"></a>为什么wait, notify 和 notifyAll这些方法不在thread类里面?</h3><p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.jianshu.com/p/04c0d796d877" target="_blank" rel="noopener">https://www.jianshu.com/p/04c0d796d877</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java面试题记录-1</title>
    <url>/2020/05/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<h2 id="根据exercise表写sql语句"><a href="#根据exercise表写sql语句" class="headerlink" title="根据exercise表写sql语句"></a>根据exercise表写sql语句</h2><h3 id="exercise表设计："><a href="#exercise表设计：" class="headerlink" title="exercise表设计："></a>exercise表设计：</h3><img src="/2020/05/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95-1/%E8%AE%BE%E8%AE%A1%E8%A1%A8.png" class="" title="设计表">

<h3 id="exercise表数据："><a href="#exercise表数据：" class="headerlink" title="exercise表数据："></a>exercise表数据：</h3><img src="/2020/05/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95-1/%E8%A1%A8%E6%95%B0%E6%8D%AE.png" class="" title="表数据">

<a id="more"></a>

<h3 id="问题1-查找答对题目最多的前两名用户ID"><a href="#问题1-查找答对题目最多的前两名用户ID" class="headerlink" title="问题1 查找答对题目最多的前两名用户ID"></a>问题1 查找答对题目最多的前两名用户ID</h3><p>SELECT user_id FROM exercise WHERE correct = 1 GROUP BY user_id ORDER BY count(*) DESC LIMIT 2;</p>
<h3 id="问题2-查找被作答次数前两名的题目ID"><a href="#问题2-查找被作答次数前两名的题目ID" class="headerlink" title="问题2 查找被作答次数前两名的题目ID"></a>问题2 查找被作答次数前两名的题目ID</h3><p>SELECT question_id FROM exercise GROUP BY question_id ORDER BY count(*) DESC LIMIT 2;</p>
<h2 id="数据表的索引如何设计？"><a href="#数据表的索引如何设计？" class="headerlink" title="数据表的索引如何设计？"></a>数据表的索引如何设计？</h2><h3 id="选择唯一性索引"><a href="#选择唯一性索引" class="headerlink" title="选择唯一性索引"></a>选择唯一性索引</h3><ul>
<li>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录</li>
</ul>
<h3 id="为常作为查询条件的字段建立索引"><a href="#为常作为查询条件的字段建立索引" class="headerlink" title="为常作为查询条件的字段建立索引"></a>为常作为查询条件的字段建立索引</h3><ul>
<li>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建⽴立索引，可以提⾼高整个表的查询速度</li>
</ul>
<h3 id="限制索引的数目"><a href="#限制索引的数目" class="headerlink" title="限制索引的数目"></a>限制索引的数目</h3><ul>
<li>索引的数目不是越多越好</li>
<li>每个索引都需要占⽤用磁盘空间，索引越多，需要的磁盘空间就越大</li>
<li>修改表时，对索引的重构和更新很麻烦</li>
<li>越多的索引，会使更新表变得很浪费时间</li>
</ul>
<h3 id="尽量使用数据量少的索引"><a href="#尽量使用数据量少的索引" class="headerlink" title="尽量使用数据量少的索引"></a>尽量使用数据量少的索引</h3><ul>
<li>如果索引的值很长，那么查询的速度会受到影响</li>
<li><ul>
<li>例如：对一个char(100)类型的字段进行全文检索需要的时间肯定比对char(10)类型的字段需要的时间更多</li>
</ul>
</li>
</ul>
<h3 id="为经常需要排序、分组和联合操作的字段建立索引"><a href="#为经常需要排序、分组和联合操作的字段建立索引" class="headerlink" title="为经常需要排序、分组和联合操作的字段建立索引"></a>为经常需要排序、分组和联合操作的字段建立索引</h3><ul>
<li>经常需要order by、group by、distinct和union等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效的避免排序操作</li>
</ul>
<h3 id="尽量使用前缀索引"><a href="#尽量使用前缀索引" class="headerlink" title="尽量使用前缀索引"></a>尽量使用前缀索引</h3><ul>
<li>如果索引字段的值很长，最好使用值的前缀来索引</li>
<li><ul>
<li>例如：text和blog类型的字段，进行全文检索会浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度</li>
</ul>
</li>
</ul>
<h3 id="删除不再使用或者很少使用的索引"><a href="#删除不再使用或者很少使用的索引" class="headerlink" title="删除不再使用或者很少使用的索引"></a>删除不再使用或者很少使用的索引</h3><ul>
<li>表中数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理理员应当定期找出这些索引，将他们删除，从而减少索引对更新操作的影响</li>
</ul>
<h3 id="小表不应建议索引-超过200w数据的表，建立索引"><a href="#小表不应建议索引-超过200w数据的表，建立索引" class="headerlink" title="小表不应建议索引(超过200w数据的表，建立索引)"></a>小表不应建议索引(超过200w数据的表，建立索引)</h3><ul>
<li>包含大量的列并且不需要搜索非空值的时候可以考虑不建索引</li>
</ul>
<h3 id="经常被用来过滤记录的字段"><a href="#经常被用来过滤记录的字段" class="headerlink" title="经常被用来过滤记录的字段"></a>经常被用来过滤记录的字段</h3><ul>
<li>primary key 字段，系统自动创建主键的索引</li>
<li>unique key 字段，系统自动创建对应的索引</li>
<li>foreign key 约束所定义的作为外键的字段</li>
<li>在查询中用来连接表的字段</li>
<li>经常用来作为排序(order by的字段)基准的字段</li>
</ul>
<h3 id="索引会占⽤用磁盘空间，创建不不必要的索引只会形成浪费"><a href="#索引会占⽤用磁盘空间，创建不不必要的索引只会形成浪费" class="headerlink" title="索引会占⽤用磁盘空间，创建不不必要的索引只会形成浪费"></a>索引会占⽤用磁盘空间，创建不不必要的索引只会形成浪费</h3><h3 id="索引的创建必须考虑数据的操作方式"><a href="#索引的创建必须考虑数据的操作方式" class="headerlink" title="索引的创建必须考虑数据的操作方式"></a>索引的创建必须考虑数据的操作方式</h3><ul>
<li>内容很少变动，经常被查询，为它多创建几个索引无所谓</li>
<li>经常性，例行性变动的表而言，则需要谨慎地创建确实必要的索引</li>
</ul>
<h2 id="如何保障mysql和redis之间的数据一致性？"><a href="#如何保障mysql和redis之间的数据一致性？" class="headerlink" title="如何保障mysql和redis之间的数据一致性？"></a>如何保障mysql和redis之间的数据一致性？</h2><p><a href="https://zhuanlan.zhihu.com/p/91770135" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91770135</a></p>
<p><a href="https://juejin.im/post/5c96fb795188252d5f0fdff2" target="_blank" rel="noopener">https://juejin.im/post/5c96fb795188252d5f0fdff2</a></p>
<h2 id="实现算法：反转链表"><a href="#实现算法：反转链表" class="headerlink" title="实现算法：反转链表"></a>实现算法：反转链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归方法</span></span><br><span class="line"><span class="comment">     * recursive</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList_recursive</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverseList_recursive(head.next);</span><br><span class="line">        <span class="comment">// 反转箭头</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法</span></span><br><span class="line"><span class="comment">     * iterative</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList_iterative</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用java实现一个线程安全的单例模式"><a href="#用java实现一个线程安全的单例模式" class="headerlink" title="用java实现一个线程安全的单例模式"></a>用java实现一个线程安全的单例模式</h2><h3 id="推荐使用枚举"><a href="#推荐使用枚举" class="headerlink" title="推荐使用枚举"></a>推荐使用枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型是线程安全的，并且只会装载一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SingletonObject instance;</span><br><span class="line"></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> SingletonObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h2><p>==对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</p>
<p>而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h2 id="Mysql查询性能优化"><a href="#Mysql查询性能优化" class="headerlink" title="Mysql查询性能优化"></a>Mysql查询性能优化</h2><p><a href="https://segmentfault.com/a/1190000011330649" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011330649</a></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL优化提高笔记</title>
    <url>/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于mysql的优化是一个综合性的技术，sql的优化只是其中的一种，其中主要包括</p>
<p>表的设计合理化(符合3大范式)。</p>
<p>添加索引(index) [普通索引、主键索引、唯一索引unique、全文索引]。</p>
<p>分表技术(水平分割、垂直分割)。</p>
<p>读写[写: update/delete/add]分离。</p>
<a id="more"></a>

<h2 id="合理设计表"><a href="#合理设计表" class="headerlink" title="合理设计表"></a>合理设计表</h2><p>在表的设计中一定条件下要满足三范式，表的范式，是首先符合第一范式, 才能满足第二范式 , 进一步满足第三范式。</p>
<p>第一范式: 即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只有数据库是关系型数据库(mysql/oracle/db2/sql server)，就自动的满足第一范式。</p>
<p>第二范式: 表中的记录是唯一的, 就满足第二范式, 通常我们设计一个主键来实现。</p>
<p>第三范式: 即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放. 比如下面的设计就是不满足第三范式：</p>
<img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/not_three.png" class="" title="not_three">

<p>表1存在冗余表2的数据，正常的设计都会设计成如下：</p>
<img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/three.png" class="" title="three">

<p>注意： 反第三范式: 但是没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。</p>
<p>在1对N的情况下，为了提高查询的效率，是允许部分字段冗余的。</p>
<p>提高效率而冗余的例子：</p>
<img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/example.png" class="" title="example">

<p>这里是battle表，但是为了提高查询效率，将student_battle和class_battle的id分别都添加了，正常情况下应该battle-&gt;student_battle-&gt;class_battle</p>
<h2 id="Sql优化"><a href="#Sql优化" class="headerlink" title="Sql优化"></a>Sql优化</h2><p>Sql的优化中，主要是对字段添加索引，主要包含有这四种索引(主键索引/唯一索引/全文索引/普通索引)</p>
<h3 id="1-主键索引添加"><a href="#1-主键索引添加" class="headerlink" title="1.主键索引添加"></a>1.主键索引添加</h3><p>当一张表，把某个列设为主键的时候，则该列就是主键索引,下面的id 列就是主键索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> auto_increment ,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">defaul</span> ‘’);</span><br></pre></td></tr></table></figure>

<p>如果你创建表时，没有指定主键索引，也可以在创建表后，在添加, 指令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> primary <span class="keyword">key</span> (列名);</span><br><span class="line">//举例</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> primary <span class="keyword">key</span> (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-普通索引"><a href="#2-普通索引" class="headerlink" title="2.普通索引"></a>2.普通索引</h3><p>一般来说，普通索引的创建，是先创建表，然后在创建普通索引</p>
<p>比如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表 (列<span class="number">1</span>,列名<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-创建全文索引"><a href="#3-创建全文索引" class="headerlink" title="3.创建全文索引"></a>3.创建全文索引</h3><p>全文索引，主要是针对对文件，文本的检索, 比如文章, 全文索引针对MyISAM有用。创建如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">       <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">       title <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">       <span class="keyword">body</span> <span class="built_in">TEXT</span>,</span><br><span class="line">       FULLTEXT (title,<span class="keyword">body</span>)</span><br><span class="line">     )<span class="keyword">engine</span>=myisam <span class="keyword">charset</span> utf8;</span><br></pre></td></tr></table></figure>

<p>如何使用全文索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> articles <span class="keyword">where</span> <span class="keyword">body</span> <span class="keyword">like</span> ‘%非科班%’;  //不会使用到全文索引</span><br><span class="line"></span><br><span class="line">// 查看是否使用索引:</span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> * <span class="keyword">from</span> articles <span class="keyword">where</span> <span class="keyword">body</span> <span class="keyword">like</span> ‘%非科班%’</span><br><span class="line"></span><br><span class="line">// 正确的用法是:</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> articles <span class="keyword">where</span> <span class="keyword">match</span>(title,<span class="keyword">body</span>) against(‘非科班’);</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ol>
<li><p>在mysql中fulltext 索引只针对 myisam生效</p>
</li>
<li><p>mysql自己提供的fulltext针对英文生效-&gt;sphinx (coreseek) 技术处理中文</p>
</li>
<li><p>使用方法是match(字段名..) against(‘关键字’)</p>
</li>
<li><p>全文索引一个 叫 停止词, 因为在一个文本中，创建索引是一个无穷大的数，因此，对一些常用词和字符，就不会创建，这些词，称为停止词.</p>
</li>
</ol>
<h3 id="4-唯一索引"><a href="#4-唯一索引" class="headerlink" title="4.唯一索引"></a>4.唯一索引</h3><p>当表的某列被指定为unique约束时，这列就是一个唯一索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 创建</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment , <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">unique</span>);</span><br></pre></td></tr></table></figure>

<p>这时, name 列就是一个唯一索引，unique字段可以为NULL,并可以有多NULL, 但是如果是具体内容，则不能重复，主键字段，不能为NULL,也不能重复。</p>
<p>创建唯一索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> 索引名  <span class="keyword">on</span> 表名 (列表..);</span><br></pre></td></tr></table></figure>

<p>查询索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc 表名  //不能够显示索引名</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span>(es) <span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">keys</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure>

<p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">index</span> 索引名; </span><br><span class="line"></span><br><span class="line">//如果删除主键索引。</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> primary <span class="keyword">key</span></span><br></pre></td></tr></table></figure>

<h3 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h3><p>由于索引本身很大，占用磁盘空间，对dml操作有影响，变慢，满足以下条件的字段，才应该创建索引。</p>
<ol>
<li><p>肯定在where条经常使用</p>
</li>
<li><p>该字段的内容不是唯一的几个值</p>
</li>
<li><p>字段内容不是频繁变化</p>
</li>
</ol>
<p>explain 可以帮助我们在不真正执行某个sql语句时，就执行mysql怎样执行，这样利用我们去分析sql指令。</p>
<img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/explain.png" class="" title="explain">

<ol>
<li><p>id：查询的序列号。</p>
</li>
<li><p>select_type：查询类型。</p>
</li>
<li><p>table：查询表名。</p>
</li>
<li><p>type：扫描方式，all表示全表扫描。</p>
</li>
<li><p>possible_keys：可是使用到的索引。</p>
</li>
<li><p>key：实际使用到的索引。</p>
</li>
<li><p>rows：该sql扫面了多少行。</p>
</li>
<li><p>Extra：sql语句额外的信息，比如排序方式</p>
</li>
</ol>
<h2 id="sql语句的小技巧"><a href="#sql语句的小技巧" class="headerlink" title="sql语句的小技巧"></a>sql语句的小技巧</h2><p>在使用group by 分组查询时，默认分组后，还会排序，可能会降低速度，在group by 后面增加 order by null 就可以防止排序。如下图所示:</p>
<img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/group_by.png" class="" title="group_by">

<img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/group_by_null.png" class="" title="group_by_null">

<p>有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept, emp <span class="keyword">where</span> dept.deptno=emp.deptno; </span><br><span class="line">// 替换成</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> dept.deptno=emp.deptno;</span><br></pre></td></tr></table></figure>

<h3 id="更多如何写出更好的sql，参考："><a href="#更多如何写出更好的sql，参考：" class="headerlink" title="更多如何写出更好的sql，参考："></a>更多如何写出更好的sql，参考：</h3><p><a href="https://www.jianshu.com/p/eccaebb6dc3c" target="_blank" rel="noopener">https://www.jianshu.com/p/eccaebb6dc3c</a></p>
<h2 id="正确的选择mysql的存储引擎"><a href="#正确的选择mysql的存储引擎" class="headerlink" title="正确的选择mysql的存储引擎"></a>正确的选择mysql的存储引擎</h2><p>Myisam : 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. ,比如 bbs 中的 发帖表，回复表。</p>
<p>INNODB : 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表。</p>
<img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/engine.png" class="" title="engine">

<p>如果你的数据库的存储引擎是myisam,请一定记住要定时进行碎片整理</p>
<h2 id="分表技术"><a href="#分表技术" class="headerlink" title="分表技术"></a>分表技术</h2><p>为什么要分表？</p>
<p>（1） 如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I/O操作</p>
<p>（2）如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响这查询的性能。</p>
<p>（3）表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p>
<p>（4） 分表技术有(水平分割和垂直分割)</p>
<h3 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h3><p>垂直分割是指数据表列的拆分，把一张列比较多的表拆分为多张表。垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。</p>
<p>垂直分割比较常见：例如博客系统中的文章表，比如文章tbl_articles<br>(id, titile, summary, content, user_id, create_time)，因为文章中的内容content会比较长，放在tbl_articles中会严重影响表的查询速度，所以将内容放到tbl_articles_detail(article_id, content)，像文章列表只需要查询tbl_articles中的字段即可。</p>
<p>垂直拆分的优点：可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p>垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。</p>
<h3 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h3><p>水平拆分是指数据表行数据的拆分，表的行数超过500万行或者单表容量超过10GB时，查询就会变慢，这时可以把一张的表的数据拆成多张表来存放。水平分表尽可能使每张表的数据量相当，比较均匀。</p>
<p>水平拆分会给应用增加复杂度，它通常在查询是需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点。</p>
<p>因为只要索引关键字不大，则在索引用于查询时，表中增加2-3倍数据量，查询时也就增加读一个索引层的磁盘次数，所以水平拆分要考虑数据量的增长速度，根据实际情况决定是否需要对表进行水平拆分。</p>
<p>水平分割最重要的是找到分割的标准，不同的表应根据业务找出不同的标准</p>
<p>用户表可以根据用户的手机号段进行分割如user183、user150、user153、user189等，每个号段就是一张表</p>
<p>用户表也可以根据用户的id进行分割，加入分3张表user0,user1,user2，如果用户的id%3=0就查询user0表，<br>如果用户的id%3=1就查询user1表</p>
<p>对于订单表可以按照订单的时间进行分表</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>实现MySQL读写分离的前提是我们已经将MySQL主从复制配置完毕，读写分离实现方式：</p>
<p>（1）配置多数据源。</p>
<p>（2）使用mysql的proxy中间件代理工具。</p>
<h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><p>MySQL的主从复制和读写分离两者有着紧密的联系，首先要部署主从复制，只有主从复制完成了才能在此基础上进行数据的读写分离。</p>
<img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/master.png" class="" title="master_slave">

<h3 id="读写分离的原理"><a href="#读写分离的原理" class="headerlink" title="读写分离的原理"></a>读写分离的原理</h3><p>读写分离就是只在主服务器上写，只在从服务器上读。基本原理是让主数据库处理事务性查询，而从服务器处理select查询。数据库复制被用来把事务性查询导致的变更同步到从数据库中。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/900e92d61861" target="_blank" rel="noopener">https://www.jianshu.com/p/900e92d61861</a></p>
<p><a href="https://www.jianshu.com/p/eccaebb6dc3c" target="_blank" rel="noopener">https://www.jianshu.com/p/eccaebb6dc3c</a></p>
]]></content>
  </entry>
  <entry>
    <title>Spring-Boot多数据源的动态切换</title>
    <url>/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="创建数据库和数据表"><a href="#创建数据库和数据表" class="headerlink" title="创建数据库和数据表"></a>创建数据库和数据表</h3><p>首先需要建立两个库进行测试，我这里使用的是master_test和slave_test两个库，</p>
<p>两个库都有一张同样的表，表名tuser</p>
<a id="more"></a>

<img src="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/master_table.png" class="" title="master table">

<img src="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/slave_table.png" class="" title="slave table">


<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--        添加druid数据源--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--        添加aop--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><h4 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 11:08 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2470170238667716941L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy= GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"id"</span>, unique=<span class="keyword">true</span>, nullable=<span class="keyword">false</span>, precision=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"name"</span>, precision=<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tuser repository</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 11:07 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TuserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Tuser</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态数据源配置"><a href="#动态数据源配置" class="headerlink" title="动态数据源配置"></a>动态数据源配置</h3><p>这里使用的数据源为druid，实现数据源之间的切换用@DataSource自定义注解，配置Aop进行切换 application.yml 配置文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">wgl-master:</span></span><br><span class="line">        <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://101.200.63.11:3306/master_test?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">      <span class="attr">wgl-slave:</span></span><br><span class="line">        <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://101.200.63.11:3306/slave_test?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br></pre></td></tr></table></figure>

<h3 id="多数据源配置类"><a href="#多数据源配置类" class="headerlink" title="多数据源配置类"></a>多数据源配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 10:55 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.druid.wgl-master"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">wglMasterDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.druid.wgl-slave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource  <span class="title">wglSlaveDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicDataSource <span class="title">dataSource</span><span class="params">(DataSource wglMasterDataSource, DataSource wglSlaveDataSource)</span> </span>&#123;</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        targetDataSources.put(<span class="string">"wgl-master"</span>,wglMasterDataSource);</span><br><span class="line">        targetDataSources.put(<span class="string">"wgl-slave"</span>, wglSlaveDataSource);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicDataSource(wglMasterDataSource, targetDataSources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态数据源切换类"><a href="#动态数据源切换类" class="headerlink" title="动态数据源切换类"></a>动态数据源切换类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态数据源切换类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 10:57 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span>  <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; contextHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicDataSource</span><span class="params">(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDefaultTargetDataSource(defaultTargetDataSource);</span><br><span class="line">        <span class="keyword">super</span>.setTargetDataSources(targetDataSources);</span><br><span class="line">        <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dataSource)</span> </span>&#123;</span><br><span class="line">        contextHolder.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义-DataSource注解"><a href="#自定义-DataSource注解" class="headerlink" title="自定义@DataSource注解"></a>自定义@DataSource注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义数据源选择注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 10:58 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataSource &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Aop切面类配置"><a href="#Aop切面类配置" class="headerlink" title="Aop切面类配置"></a>Aop切面类配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Aop切面类配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 11:01 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.wgl.cupid.annotation.DataSource)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataSourcePointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"dataSourcePointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        DataSource dataSource = method.getAnnotation(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(dataSource == <span class="keyword">null</span>)&#123;</span><br><span class="line">            DynamicDataSource.setDataSource(<span class="string">"wgl-master"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            DynamicDataSource.setDataSource(dataSource.name());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DynamicDataSource.clearDataSource();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动配置注解信息，重要（不然运行会报错）"><a href="#启动配置注解信息，重要（不然运行会报错）" class="headerlink" title="启动配置注解信息，重要（不然运行会报错）"></a>启动配置注解信息，重要（不然运行会报错）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude= &#123;DataSourceAutoConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;DynamicDataSourceConfig<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CupidApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CupidApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试controller"><a href="#测试controller" class="headerlink" title="测试controller"></a>测试controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 11:04 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicUserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TuserRepository tuserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list/slave"</span>)</span><br><span class="line">    <span class="meta">@DataSource</span>(name = <span class="string">"wgl-slave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Tuser&gt; <span class="title">listSlave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuserRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list/master"</span>)</span><br><span class="line">    <span class="meta">@DataSource</span>(name = <span class="string">"wgl-master"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Tuser&gt; <span class="title">listMaster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuserRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><h4 id="http-localhost-8080-list-master"><a href="#http-localhost-8080-list-master" class="headerlink" title="http://localhost:8080/list/master"></a><a href="http://localhost:8080/list/master" target="_blank" rel="noopener">http://localhost:8080/list/master</a></h4><img src="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/master_result.png" class="" title="master result">

<h4 id="http-localhost-8080-list-slave"><a href="#http-localhost-8080-list-slave" class="headerlink" title="http://localhost:8080/list/slave"></a><a href="http://localhost:8080/list/slave" target="_blank" rel="noopener">http://localhost:8080/list/slave</a></h4><img src="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/slave_result.png" class="" title="slave result">


<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://mp.weixin.qq.com/s/HNr97Fqonq3SZkJj21cDlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HNr97Fqonq3SZkJj21cDlg</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot实现通过url下载pdf到本地</title>
    <url>/2020/06/06/SpringBoot%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%BF%87url%E4%B8%8B%E8%BD%BDpdf%E5%88%B0%E6%9C%AC%E5%9C%B0/</url>
    <content><![CDATA[<p>最近有需求是点击下载按钮后下载指定url的pdf文件到本地</p>
<p>下面通过<strong>SpringBoot</strong>来实现一下：</p>
<a id="more"></a>

<h4 id="思路就是："><a href="#思路就是：" class="headerlink" title="思路就是："></a><strong>思路</strong>就是：</h4><ol>
<li>解析url，建立连接获取输入流</li>
<li>copy输入流到输出流中，进行相关设置并返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/download"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(@RequestParam(<span class="string">"url"</span>)</span> String urlStr, HttpServletResponse response) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">        <span class="comment">//设置超时间为5秒</span></span><br><span class="line"><span class="comment">//        conn.setConnectTimeout(5*1000);</span></span><br><span class="line">        <span class="comment">//防止屏蔽程序抓取而返回403错误</span></span><br><span class="line">        conn.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)"</span>);</span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = conn.getInputStream();</span><br><span class="line">            OutputStream outputStream = response.getOutputStream();) &#123;</span><br><span class="line">            response.setContentType(<span class="string">"application/x-download"</span>);</span><br><span class="line">            response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename=test.pdf"</span>);</span><br><span class="line">            <span class="comment">// 将输入流拷贝到输出流中</span></span><br><span class="line">            IOUtils.copy(inputStream, outputStream);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot整合Redis并用Redis实现定时任务</title>
    <url>/2020/07/02/SpringBoot%E6%95%B4%E5%90%88Redis%E5%B9%B6%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis是一种可基于内存也可基于持久话的日志型、key-value数据库。因为性能高，存储数据类型丰富等优势常被用作数据缓存。</p>
<p>下面介绍Redis集成到SpringBoot2.2.4和Redis定时任务的实现。</p>
<a id="more"></a>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>前提要在本地安装好redis或者是使用云redis，这里就不说了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--      redis                      --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;!-- 1.5的版本默认采用的连接池技术是jedis  2.0以上版本默认连接池是lettuce, 在这里采用jedis，所以需要排除lettuce的jar --&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;io.lettuce&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;lettuce-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- 添加jedis客户端 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--spring2.0集成redis所需common-pool2--&gt;</span><br><span class="line">        &lt;!-- 必须加上，jedis依赖此  --&gt;</span><br><span class="line">        &lt;!-- spring boot 2.0 的操作手册有标注 大家可以去看看 地址是：https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-boot&#x2F;docs&#x2F;2.0.3.RELEASE&#x2F;reference&#x2F;htmlsingle&#x2F;--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.5.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="在yml中配置redis"><a href="#在yml中配置redis" class="headerlink" title="在yml中配置redis"></a>在yml中配置redis</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">#数据库索引，默认为0</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#服务器地址，默认localhost</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment">#端口，默认6379</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#密码，默认为空</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">#连接池最大连接数，默认为8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment">#连接池最大阻塞等待时间，使用负值表示没有限制</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#连接池最大空闲连接，默认为8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment">#连接池中的最小空闲连接，默认为0</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#连接超时时间(毫秒)    </span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="创建redis的Service类或者是Util类"><a href="#创建redis的Service类或者是Util类" class="headerlink" title="创建redis的Service类或者是Util类"></a>创建redis的Service类或者是Util类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入redis缓存（不设置expire存活时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"写入redis缓存失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入redis缓存（设置expire存活时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, String value, Long expire)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            redisTemplate.expire(key, expire, TimeUnit.SECONDS);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"写入redis缓存（设置expire存活时间）失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取redis缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations operations = redisTemplate.opsForValue();</span><br><span class="line">            result = operations.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"读取redis缓存失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断redis缓存中是否有对应的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"判断redis缓存中是否有对应的key失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis根据key删除对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(exists(key))&#123;</span><br><span class="line">                redisTemplate.delete(key);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"redis根据key删除对应的value失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis根据keys批量删除对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String... keys)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是SpringBoot集成Redis的步骤了，下面说一下Redis完成定时任务。</p>
<h2 id="使用定时任务的场景"><a href="#使用定时任务的场景" class="headerlink" title="使用定时任务的场景"></a>使用定时任务的场景</h2><p>使用Java做过项目的人大概都用过定时器。一般来说，项目里订单模块和评论模块，都会涉及到定时任务执行。比如说：</p>
<p>用户下订单后，需要在5分钟内完成支付，否则订单关闭；</p>
<p>用户在完成订单后，如果没有评论，过一星期，系统自动评论，并完结。</p>
<h2 id="使用Redis解决"><a href="#使用Redis解决" class="headerlink" title="使用Redis解决"></a>使用Redis解决</h2><p>Redis中有一个expire命令，用来设置key的过期时间。使用发布订阅，可以接收到key的过期提醒，当key过期时，再执行取消订单的逻辑，就可以了。</p>
<h2 id="Redis过期通知"><a href="#Redis过期通知" class="headerlink" title="Redis过期通知"></a>Redis过期通知</h2><p>要使用Redis的过期通知功能，需要首先开启该功能。</p>
<p>在配置文件中加入如下语句：</p>
<p>notify-keyspace-events Ex</p>
<h2 id="在SpringBoot中编写代码"><a href="#在SpringBoot中编写代码" class="headerlink" title="在SpringBoot中编写代码"></a>在SpringBoot中编写代码</h2><p>首先写接收通知的处理方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisMessageReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收redis消息，并处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 过期的redis key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通知的key是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写频道订阅的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis 订阅频道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listenerAdapter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory connectionFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            MessageListenerAdapter listenerAdapter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 订阅通道，key过期时通知</span></span><br><span class="line">        container.addMessageListener(listenerAdapter, <span class="keyword">new</span> PatternTopic(<span class="string">"__keyevent@0__:expired"</span>));</span><br><span class="line">        <span class="comment">// 可以订阅多个通道</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置redis事件监听处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receiver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MessageListenerAdapter <span class="title">listenerAdapter</span><span class="params">(RedisMessageReceiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageListenerAdapter(receiver, <span class="string">"receiveMessage"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了</p>
<h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><p>运行程序之后随意设置一个key，并设置过期时间：</p>
<img src="/2020/07/02/SpringBoot%E6%95%B4%E5%90%88Redis%E5%B9%B6%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/key.png" class="" title="key">

<p>过了过期时间十秒后会收到控制台输出：</p>
<img src="/2020/07/02/SpringBoot%E6%95%B4%E5%90%88Redis%E5%B9%B6%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/out.png" class="" title="out">


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000020906185" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020906185</a></p>
<p><a href="https://www.zhangjava.com/%E4%BD%BF%E7%94%A8Redis%E5%AE%8C%E6%88%90%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" target="_blank" rel="noopener">https://www.zhangjava.com/%E4%BD%BF%E7%94%A8Redis%E5%AE%8C%E6%88%90%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</a></p>
]]></content>
  </entry>
  <entry>
    <title>cookie和session的区别</title>
    <url>/2020/04/30/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="http无状态和session"><a href="#http无状态和session" class="headerlink" title="http无状态和session"></a>http无状态和session</h2><p>由于HTTP协议是<strong>无状态</strong>的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.</p>
<a id="more"></a>

<p>典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。</p>
<p>这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。</p>
<p>集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候Session信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放Session。</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。</p>
<p>实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。</p>
<p>有人问，如果客户端的浏览器禁用了Cookie怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p>
<p>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</p>
<h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><p>所以，总结一下：<em>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式</em>。</p>
<p>cookie和session的<strong>共同之处</strong>在于：cookie和session都是用来<strong>跟踪浏览器用户身份</strong>的会话方式。</p>
<p>cookie 和session的<strong>区别</strong>是：cookie数据保存在<strong>客户端</strong>，session数据保存在<strong>服务器端</strong>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.imooc.com/article/3369" target="_blank" rel="noopener">https://www.imooc.com/article/3369</a><br><a href="https://www.zhihu.com/question/19786827/answer/28752144" target="_blank" rel="noopener">https://www.zhihu.com/question/19786827/answer/28752144</a></p>
]]></content>
  </entry>
  <entry>
    <title>Spring自动注入单例和多例如何选择</title>
    <url>/2020/05/03/Spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E5%8D%95%E4%BE%8B%E5%92%8C%E5%A4%9A%E4%BE%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h3 id="Spring中bean的scope属性，有如下5种类型："><a href="#Spring中bean的scope属性，有如下5种类型：" class="headerlink" title="Spring中bean的scope属性，有如下5种类型："></a>Spring中bean的scope属性，有如下5种类型：</h3><p><strong>singleton</strong> 表示在spring容器中的单例，通过spring容器获得该bean时总是返回唯一的实例</p>
<p><strong>prototype</strong> 表示每次获得bean都会生成一个新的对象</p>
<p><strong>request</strong> 表示在一次http请求内有效（只适用于web应用）</p>
<p><strong>session</strong> 表示在一个用户会话内有效（只适用于web应用）</p>
<p><strong>globalSession</strong> 表示在全局会话内有效（只适用于web应用）</p>
<p><em>在多数情况，我们只会使用singleton和prototype两种scope</em>，如果在spring配置文件内未指定scope属性，默认为singleton。</p>
<a id="more"></a>

<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>所谓单例就是所有的请求都用一个对象来处理，比如我们常用的service和dao层的对象通常都是单例的，而多例则指每个请求用一个新的对象来处理</p>
<p><strong>之所以用单例，是因为没必要每个请求都新建一个对象，这样子既浪费CPU又浪费内存； 之所以用多例，是为了防止并发问题。</strong></p>
<p>即一个请求改变了对象的状态，此时对象又处理另一个请求，而之前请求对对象状态的改变导致了对象对另一个请求做了错误的处理；</p>
<p>用单例和多例的标准只有一个： <strong>当对象含有可改变的状态时（更精确的说就是在实际应用中该状态会改变），则多例，否则单例</strong>；</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://blog.csdn.net/zhang_dianliang/article/details/76850906" target="_blank" rel="noopener">https://blog.csdn.net/zhang_dianliang/article/details/76850906</a></p>
<p><a href="https://www.imooc.com/wenda/detail/385159" target="_blank" rel="noopener">https://www.imooc.com/wenda/detail/385159</a></p>
]]></content>
  </entry>
  <entry>
    <title>Spring定时任务-Scheduled注解使用方式</title>
    <url>/2020/06/30/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-Scheduled%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用@Scheduled cron表达式标注任务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(testTask<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="cron表达式的语法"><a href="#cron表达式的语法" class="headerlink" title="cron表达式的语法"></a>cron表达式的语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 按顺序依次为</span><br><span class="line">1  秒（0~59）</span><br><span class="line">2  分钟（0~59）</span><br><span class="line">3 小时（0~23）</span><br><span class="line">4  天（0~31）</span><br><span class="line">5 月（0~11）</span><br><span class="line">6  星期（1~7 1&#x3D;SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）</span><br><span class="line">7.年份（1970－2099）</span><br><span class="line">其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18&#x2F;4)(&#x2F;表示每隔4小时),一个列表(1,3,5),通配符。由于&quot;月份中的日期&quot;和&quot;星期中的日期&quot;这两个元素互斥的,必须要对其中一个设置?.</span><br><span class="line"> 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点</span><br><span class="line"> 0 0&#x2F;30 9-17 * * ?   朝九晚五工作时间内每半小时</span><br><span class="line"> 0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line"> &quot;0 0 12 * * ?&quot; 每天中午12点触发 </span><br><span class="line"> &quot;0 15 10 ? * *&quot; 每天上午10:15触发 </span><br><span class="line"> &quot;0 15 10 * * ?&quot; 每天上午10:15触发 </span><br><span class="line"> &quot;0 15 10 * * ? *&quot; 每天上午10:15触发 </span><br><span class="line"> &quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发 </span><br><span class="line"> &quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发 </span><br><span class="line"> &quot;0 0&#x2F;5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发 </span><br><span class="line"> &quot;0 0&#x2F;5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </span><br><span class="line"> &quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发 </span><br><span class="line"> &quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发 </span><br><span class="line"> &quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发 </span><br><span class="line"> &quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发 </span><br><span class="line"> &quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发 </span><br><span class="line"> &quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发 </span><br><span class="line"> &quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发 </span><br><span class="line"> &quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发 </span><br><span class="line"> 有些子表达式能包含一些范围或列表</span><br><span class="line"> 例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”</span><br><span class="line"> “*”字符代表所有可能的值</span><br><span class="line"> “&#x2F;”字符用来指定数值的增量</span><br><span class="line"> 例如：在子表达式（分钟）里的“0&#x2F;15”表示从第0分钟开始，每15分钟</span><br><span class="line">          在子表达式（分钟）里的“3&#x2F;20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样</span><br><span class="line"> “？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值</span><br><span class="line"> 当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</span><br><span class="line"> “L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写</span><br><span class="line"> 如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”表示这个月的倒数第６天</span><br><span class="line"> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</span><br><span class="line"> W 字符代表着平日(Mon-Fri)，并且仅能用于日域中。它用来指定离指定日的最近的一个平日。大部分的商业处理都是基于工作周的，所以 W 字符可能是非常重要的。</span><br><span class="line"> 例如，日域中的 15W 意味着 &quot;离该月15号的最近一个平日。&quot; 假如15号是星期六，那么 trigger 会在14号(星期五)触发，因为星期四比星期一离15号更近。</span><br><span class="line"> C：代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。</span><br><span class="line"> 字段   允许值   允许的特殊字符</span><br><span class="line"> 秒           0-59           , - * &#x2F;</span><br><span class="line"> 分           0-59           , - * &#x2F;</span><br><span class="line"> 小时           0-23           , - * &#x2F;</span><br><span class="line"> 日期           1-31           , - * ? &#x2F; L W C</span><br><span class="line"> 月份           1-12 或者 JAN-DEC           , - * &#x2F;</span><br><span class="line"> 星期           1-7 或者 SUN-SAT           , - * ? &#x2F; L C #</span><br><span class="line"> 年（可选）           留空, 1970-2099           , - * &#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>如果我的任务在5秒内没有执行完呢？spring会怎么处理呢？</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"*/5 * * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">6</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-06-11 16:02:50.035 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:02:56.496 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:03:00.006 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:03:06.013 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:03:10.115 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:03:17.267 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:03:20.055 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:03:26.164 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure>

<p>我们可以发现，spring他的处理方式是等待上一个任务执行完成后，再去执行下一个任务，也就是说spring的定时任务<strong>默认是单线程</strong>的，而不会开启另一条线程去执行任务。</p>
<p>眼尖的小伙伴应该发现任务执行的时间还是怪怪的，任务开始到结束的时间间隔确实是6s，但是下一个任务的开始时间和上一个任务的结束时间之间为什么差了4s呢？这个时间是怎么设定的呢？</p>
<p>这个问题和spring处理cron表达式这种定时任务的机制有关，我们稍后再说，先讲讲@Scheduled注解的另外两个属性：<strong>fixedRate和fixedDelay</strong></p>
<h2 id="fixedDelay"><a href="#fixedDelay" class="headerlink" title="fixedDelay"></a>fixedDelay</h2><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5</span>*<span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">6</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-06-11 16:30:56.246 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:31:03.114 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:31:08.122 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:31:14.139 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:31:19.149 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:31:25.261 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:31:30.269 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:31:36.385 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure>

<p>我们可以发现，这个结果和上一个使用cro表达式的结果好像啊。但是仔细看我们就会发现，这次所有的时间都是我们配置的：任务开始到结束间隔6s，上一个任务结束时间到下一个任务开始时间是5秒，这样看来是比较符合我们的设置的。</p>
<p>fixedDelay是设定上一个任务结束后多久执行下一个任务，也就是<strong>fixedDelay只关心上一任务的结束时间和下一任务的开始时间</strong>。</p>
<h2 id="fixedRate"><a href="#fixedRate" class="headerlink" title="fixedRate"></a>fixedRate</h2><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5</span>*<span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">6</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-06-11 16:54:29.613 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:54:36.113 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:54:36.118 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:54:42.580 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:54:42.607 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:54:48.632 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:54:48.639 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:54:55.188 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure>

<p>这次我们可以看到，上一个任务结束后，下一个任务立刻开始执行了，结合第一次测试，我们就可以推断，<strong>fixedRate设置的上一个任务的开始时间到下一个任务开始时间的间隔</strong>，那我们的推断对不对呢？这次我们把任务执行时间改成2s，测试走起~</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5</span>*<span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-06-11 17:08:37.500 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:08:39.510 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:08:43.086 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:08:45.093 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:08:48.025 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:08:50.083 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:08:53.239 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:08:55.245 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure>

<p>结果和我们推断的一致，两个任务的开始时间间隔是5s，当到达任务的开始执行时间，但上一个任务却没有完成时，spring会等待上一个任务执行完，并立即开始执行本次任务。</p>
<h2 id="Cron执行机制"><a href="#Cron执行机制" class="headerlink" title="Cron执行机制"></a>Cron执行机制</h2><p>上面介绍了cron表达式、fixedRate和fixedDelay三种方式，但还有一个遗留问题，那就是cron的执行机制，为什么使用它时两个任务间隔并不固定呢？其实spring在处理使用cron表达式这种定时任务时，其实依旧关注的是任务的开始时间，但是他和fixedDelay不同的是，<strong>他会在配置任务开始时判断任务是否可以执行，如果可以则执行，如果不可以，那么他将不执行此次任务，等待下一次执行</strong>。比如下图</p>
<img src="/2020/06/30/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-Scheduled%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/cron.png" class="" title="cron">

<p>AB两个任务配置的执行规则都是每隔5s执行，A任务执行时间是4s，而B任务执行时间是7s。</p>
<p>A任务可以在执行内执行完任务，所以每隔5s他就会正常执行，0s开始，4s时结束，那么在5s的时候他会再次执行，如此反复。</p>
<p>而B任务的执行时间是7s，执行时间超过了任务的间隔时间，就如图中例子，B任务在10s开始，执行时间持续了7s，当15s的时候本来应该是开始执行第二次，但由于第一次任务还未执行完成，所以第二次任务将不会执行，而是到20s要开始执行第三次任务的时候，再次判断，发现上一次B任务已经执行完毕，这时才开始再次执行B任务。</p>
<p>还记得我们刚开始使用cron表达式做了一个执行时间为6s，间隔5s执行的测试任务吗？这次我们改一改，将执行时间改为8s，再次测试。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">8</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-06-11 17:54:30.014 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:54:38.033 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:54:40.488 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:54:49.617 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:54:50.260 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:54:58.270 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:55:00.845 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:55:08.856 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure>

<p>对比执行时间为6s的测试结果，可以发现两次任务开始的时间都是在下下一个5s的时候，也就是证实了之前等待的结论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、fixedRate配置了上一次任务的开始时间到下一次任务的开始时间的间隔，每次任务都会执行；</p>
<p>2、fixedDelay配置了上一次任务的结束时间到下一次任务的开始时间的间隔，每次任务都会执行；</p>
<p>3、cron表达式配置了在哪一刻执行任务，会在配置的任务开始时间判断任务是否可以执行，如果能则执行，不能则会跳过本次执行；</p>
<p>4、<strong>如果是强调任务间隔的定时任务，建议使用fixedRate和fixedDelay，如果是强调任务在某时某分某刻执行的定时任务，建议使用cron表达式。</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000015253688" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015253688</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何记忆Spring-Bean的生命周期</title>
    <url>/2020/06/23/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>“请你描述下 Spring Bean 的生命周期？”，这是面试官考察 Spring 的常用问题，可见是 Spring 中很重要的知识点。</p>
<img src="/2020/06/23/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/total_process.png" class="" title="总体流程图">

<p>其实要记忆该过程，还是需要我们先去理解，本文将从以下两方面去帮助理解 Bean 的生命周期：</p>
<ul>
<li><p>生命周期的概要流程：对 Bean 的生命周期进行概括，并且结合代码来理解；</p>
</li>
<li><p>扩展点的作用：详细介绍 Bean 生命周期中所涉及到的扩展点的作用。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="2-生命周期的概要流程"><a href="#2-生命周期的概要流程" class="headerlink" title="2. 生命周期的概要流程"></a>2. 生命周期的概要流程</h2><p>Bean 的生命周期概括起来就是 <strong>4</strong> 个阶段：</p>
<p><strong>实例化</strong>（Instantiation）</p>
<p><strong>属性赋值</strong>（Populate）</p>
<p><strong>初始化</strong>（Initialization）</p>
<p><strong>销毁</strong>（Destruction）</p>
<img src="/2020/06/23/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/classify.png" class="" title="划分阶段的总体图">

<ol>
<li>实例化：第 1 步，实例化一个 bean 对象；</li>
</ol>
<ol start="2">
<li>属性赋值：第 2 步，为 bean 设置相关属性和依赖；</li>
</ol>
<ol start="3">
<li>初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；</li>
</ol>
<ol start="4">
<li>销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。</li>
</ol>
<p>下面我们结合代码来直观的看下，在 doCreateBean() 方法中能看到依次执行了这 4 个阶段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 实例化</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 属性赋值</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 3. 初始化</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 销毁-注册回调接口</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于初始化包含了第 3~7步，较复杂，所以我们进到 initializeBean() 方法里具体看下其过程（注释的序号对应图中序号）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3. 检查 Aware 相关接口并设置相关依赖</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. BeanPostProcessor 前置处理</span></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">    <span class="comment">// 6. 若配置自定义的 init-method方法，则执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. BeanPostProceesor 后置处理</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 invokInitMethods() 方法中会检查 InitializingBean 接口和 init-method 方法，销毁的过程也与其类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DisposableBeanAdapter.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 9. 若实现 DisposableBean 接口，则执行 destory()方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, <span class="keyword">this</span>.acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 10. 若配置自定义的 detory-method 方法，则执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToInvoke = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (methodToInvoke != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring 的源码我们可以直观的看到其执行过程，而我们记忆其过程便可以从这 4 个阶段出发，实例化、属性赋值、初始化、销毁。其中细节较多的便是初始化，涉及了 Aware、BeanPostProcessor、InitializingBean、init-method 的概念。这些都是 Spring 提供的扩展点，其具体作用将在下一节讲述。</p>
<h2 id="3-扩展点的作用"><a href="#3-扩展点的作用" class="headerlink" title="3. 扩展点的作用"></a>3. 扩展点的作用</h2><h3 id="3-1-Aware-接口"><a href="#3-1-Aware-接口" class="headerlink" title="3.1 Aware 接口"></a>3.1 Aware 接口</h3><p>若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以<strong>通过让 bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源</strong>。 </p>
<p>Spring 中提供的 Aware 接口有：</p>
<ol>
<li><p>BeanNameAware：注入当前 bean 对应 beanName；</p>
</li>
<li><p>BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader；</p>
</li>
<li><p>BeanFactoryAware：注入 当前BeanFactory容器 的引用。</p>
</li>
</ol>
<p>其代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是针对 BeanFactory 类型的容器，而对于 ApplicationContext 类型的容器，也提供了 Aware 接口，只不过这些 Aware 接口的注入实现，是通过 BeanPostProcessor 的方式注入的，但其作用仍是注入依赖。</p>
<ol>
<li><p>EnvironmentAware：注入 Enviroment，一般用于获取配置属性；</p>
</li>
<li><p>EmbeddedValueResolverAware：注入 EmbeddedValueResolver（Spring EL解析器），一般用于参数解析；</p>
</li>
<li><p>ApplicationContextAware（ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware）：注入 ApplicationContext 容器本身。</p>
</li>
</ol>
<p>其代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ApplicationContextAwareProcessor.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">        ((EnvironmentAware)bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">        ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">        ((ResourceLoaderAware)bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">        ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">        ((MessageSourceAware)bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">        ((ApplicationContextAware)bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-BeanPostProcessor"><a href="#3-2-BeanPostProcessor" class="headerlink" title="3.2 BeanPostProcessor"></a>3.2 BeanPostProcessor</h3><p>BeanPostProcessor 是 Spring 为修改 bean提供的强大扩展点，其可作用于容器中所有 bean，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化前置处理</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化后置处理</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用场景有：</p>
<ol>
<li><p>对于标记接口的实现类，进行自定义处理。例如3.1节中所说的ApplicationContextAwareProcessor，为其注入相应依赖；再举个例子，自定义对实现解密接口的类，将对其属性进行解密处理；</p>
</li>
<li><p>为当前对象提供代理实现。例如 Spring AOP 功能，生成对象的代理类，然后返回。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="comment">// 返回代理类</span></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-InitializingBean-和-init-method"><a href="#3-3-InitializingBean-和-init-method" class="headerlink" title="3.3 InitializingBean 和 init-method"></a>3.3 InitializingBean 和 init-method</h3><p>InitializingBean 和 init-method 是 Spring 为 <strong>bean 初始化</strong>提供的扩展点。</p>
<p>InitializingBean接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 afterPropertiesSet() 方法写初始化逻辑。</p>
<p>指定 init-method 方法，指定初始化方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"com.chaycao.Demo"</span> <span class="attr">init-method</span>=<span class="string">"init()"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DisposableBean 和 destory-method 与上述类似，就不描述了。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>最后总结下如何记忆 Spring Bean 的生命周期：</p>
<ul>
<li><p>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</p>
</li>
<li><p>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作；</p>
</li>
<li><p>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</p>
</li>
</ul>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><p><a href="https://juejin.im/post/5e4791a7f265da5715630629" target="_blank" rel="noopener">https://juejin.im/post/5e4791a7f265da5715630629</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何通俗易懂的理解翻墙</title>
    <url>/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/</url>
    <content><![CDATA[<p><strong>为了更好的理解翻墙，首先先了解一下互联网是怎么工作的：</strong></p>
<a id="more"></a>

<h2 id="互联网怎么工作的"><a href="#互联网怎么工作的" class="headerlink" title="互联网怎么工作的"></a>互联网怎么工作的</h2><p>假如没有互联网，我们家里有两台电脑，这两台电脑需要互相发送文件，那我们需要用网线把他们连起来，就可以互相传输文件了</p>
<img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/two_computers.png" class="" title="two computers">

<p>假如我们又增加了三台电脑，一共有五台电脑，那么我们就把他们一对一的连接起来，每台电脑都需要4个网线接口，就组成了一个局域网。</p>
<img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/five_computers.png" class="" title="five computers">

<p>但是如果我们继续增加电脑，就会发现这种一对一的连接方式就会非常复杂了，所以这个时候就增加了一个控制中心，这个控制中心就是我们熟悉的<strong>路由器</strong>。</p>
<p>每台电脑只需要连接路由器，然后路由器统一协调这些电脑之前的传输问题</p>
<img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/router.png" class="" title="router">

<p>然后我们再往大了想，如果我们想给同学家发文件，也就是一个局域网向另外一个局域网发送文件，我们就只需要把两家的路由器连上就可以发送文件了。</p>
<img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/two_routers.png" class="" title="two routers">

<p>继续往下想就会发现开始的问题，各个局域网的路由器进行一对一的连接变得异常复杂。</p>
<p>所以我们就新增了一个控制中心<strong>ISP</strong>，也就是我们说的互联网服务供应商，我们可以把它想象成更大号的路由器。</p>
<img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/ISP.png" class="" title="two ISP">

<p>这里家里的路由器只需要连接我们这个区域的ISP。</p>
<p>各个区域的ISP进行连接，这样我们的互联网就形成了。</p>
<h2 id="翻墙的原理"><a href="#翻墙的原理" class="headerlink" title="翻墙的原理"></a>翻墙的原理</h2><p>先说一下现象，我们访问部分网站，比如google的时候就会出现下面的现象：</p>
<img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/page_not_found.png" class="" title="page not found">

<p>我们输入一个网址访问一个网站，其实就是通过DNS找到网址对应的IP地址，然后访问网站的服务器，从网站服务器获取相应信息</p>
<img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/DNS.png" class="" title="DNS">

<p>举个例子：</p>
<p>比如小明通过百度经常访问大姐姐小姐姐的视频网站，然后百度就把这个情况向爸爸反映了，小明的爸爸为了小明的健康，就<strong>让DNS服务器不再查询大姐姐小姐姐网站的IP地址</strong>，这样小明就打不开网站了。</p>
<p>但是小明通过<strong>修改电脑host</strong>的方式，再一次成功的访问了网站，小明爸爸一气之下在网络传输中增加了一个关卡，告诉关卡看见数据包有大姐姐小姐姐字样的都不能通过，小明就又打不开网站了。</p>
<p>然后网站就给<strong>数据包加密</strong>，本来数据包上写的是大姐姐小姐姐，加密之后写的是办公用品，小明又一次打开了网站。小明爸爸又告诉关卡，只要是这个网站的IP地址都不能通过，所以小明又打不开网站了。</p>
<p>然后小明想了一个办法，<strong>把发送出去的数据包先进行完全的加密，通过关卡之后先传到另外一个服务器上，让这个服务器把数据包解密，然后让这个服务器去访问大姐姐小姐姐的网站，收到网站的数据包之后，服务器再进行完全的加密，通过关卡之后再解密，</strong>这样小明就再一次打开了网站。</p>
<h2 id="VPN翻墙原理"><a href="#VPN翻墙原理" class="headerlink" title="VPN翻墙原理"></a>VPN翻墙原理</h2><p>有些网站我们是没有办法打开的，这个是因为这中间有一个<strong>长城防火墙</strong>(GFW)，这个防火墙的作用就是检查这些数据包。</p>
<p>比如我们打开一个网站，DNS服务器就会告诉我们电脑，没有查到这个网址所对应的IP地址或者是长城防火墙发现这些数据包是被屏蔽网站的IP地址，就会把数据包拦下，这个就是我们没办法访问被屏蔽网站的原因。</p>
<p>为了能访问这些被屏蔽的网站，我们就用到了VPN。</p>
<p>当我们打开VPN之后，VPN就会在电脑上<strong>虚拟出一个IP地址</strong>。当电脑要传输数据包的时候，这个即将传输的数据包和没有开VPN的时候一样，先用盒子装好，然后写上寄件人和收件人的IP地址。</p>
<p>之后这个数据包会交给电脑的VPN，VPN就会对这个数据包进行加密，相当于又给数据包套了一个盒子，然后这个盒子的寄件人地址写的是刚才虚拟出来的IP地址，收件人地址写的是VPN服务器的IP地址，然后这个数据包就可以发送出去了。</p>
<p>因为<strong>这个数据包的目的地并不是被屏蔽网站的IP地址，而且数据包也加过密</strong>，防火墙自然也检测不出什么问题。</p>
<p>当数据包到了VPN的服务器之后，就会对数据包解密，再把里面的数据传给网站的服务器，网站服务器再传数据包给VPN服务器，VPN服务器把数据加密之后，又传回给我们，这个就是VPN的工作原理。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.youtube.com/watch?v=EUKmF_IKttc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EUKmF_IKttc</a><br><a href="https://www.youtube.com/watch?v=ZT-q6mJ-e3g" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ZT-q6mJ-e3g</a></p>
]]></content>
  </entry>
</search>
