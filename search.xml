<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java方向-基础知识体系及结构-网络基础-持续更新中</title>
      <link href="/2020/09/02/Java%E6%96%B9%E5%90%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%8F%8A%E7%BB%93%E6%9E%84-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
      <url>/2020/09/02/Java%E6%96%B9%E5%90%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%8F%8A%E7%BB%93%E6%9E%84-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>牛客网-java方向-基础知识体系及结构-网络基础-面试常考知识点</p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java方向-基础知识体系及结构-java-持续更新中</title>
      <link href="/2020/09/02/Java%E6%96%B9%E5%90%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%8F%8A%E7%BB%93%E6%9E%84-java-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
      <url>/2020/09/02/Java%E6%96%B9%E5%90%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%8F%8A%E7%BB%93%E6%9E%84-java-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>牛客网-java方向-基础知识体系及结构-java-面试常考知识点</p><a id="more"></a><h3 id="1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h3><p>Java虚拟机是一个<strong>可以执行Java字节码的虚拟机进程</strong>。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p><p>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道<strong>底层硬件平台的指令长度和其他特性</strong>。</p><p>再说说java的<strong>跨平台</strong>吧:</p><p>java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，<strong>.class字节码文件是与平台无关的</strong>），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以<strong>java所谓的跨平台就是在不同平台上安装了不同的jvm</strong>，而<strong>在不同平台上生成的.class文件都是一样的</strong>，而<strong>.class文件再由对应平台的jvm解释成对应平台的机器码执行</strong></p><h3 id="2-JDK和JRE的区别是什么？"><a href="#2-JDK和JRE的区别是什么？" class="headerlink" title="2. JDK和JRE的区别是什么？"></a>2. JDK和JRE的区别是什么？</h3><p>JRE： Java Runtime Environment </p><p>JDK：Java Development Kit</p><p><strong>JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。</strong>是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的<strong>用户</strong>使用的。</p><p><strong>JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的</strong>。<strong>JDK包含了JRE</strong>，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。</p><p><strong>如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。</strong></p><p>JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本 </p><h3 id="3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个static的方法？"><a href="#3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个static的方法？" class="headerlink" title="3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个static的方法？"></a>3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个static的方法？</h3><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p><p>Java中static方法不能被覆盖，因为<strong>方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的</strong>。static方法跟类的任何实例都不相关，所以概念上不适用。</p><h3 id="4-是否可以在static环境中访问非static变量？"><a href="#4-是否可以在static环境中访问非static变量？" class="headerlink" title="4. 是否可以在static环境中访问非static变量？"></a>4. 是否可以在static环境中访问非static变量？</h3><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。<strong>当类被Java虚拟机载入的时候，会对static变量进行初始化。</strong>如果你的代码尝试不用实例来访问非static的变量，编译器会报错，<strong>因为这些变量还没有被创建出来，还没有跟任何实例关联上</strong>。</p><h3 id="5-Java支持的数据类型有哪些？"><a href="#5-Java支持的数据类型有哪些？" class="headerlink" title="5. Java支持的数据类型有哪些？"></a>5. Java支持的数据类型有哪些？</h3><p>Java支持的数据类型包括两种：</p><p>一种是<strong>基本数据类型</strong>，包含byte，char,short, boolean ,int , long, float,double;</p><p>另一种是<strong>引用类型</strong>：如String等，其实是对象的引用，<strong>JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中</strong>，通过地址来找到堆中的对象的过程，即为引用类型。</p><h3 id="6-接口和抽象类的区别是什么？"><a href="#6-接口和抽象类的区别是什么？" class="headerlink" title="6. 接口和抽象类的区别是什么？"></a>6. 接口和抽象类的区别是什么？</h3><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p><p>接口中所有的方法隐含的<strong>都是抽象的</strong>。而抽象类则可以<strong>同时包含抽象和非抽象的方法</strong>。</p><p>类可以实现很多个接口，但是只能继承一个抽象类</p><p>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p><p>抽象类可以在不提供接口方法实现的情况下实现接口。</p><p>Java<strong>接口中声明的变量默认都是final的</strong>。<strong>抽象类可以包含非final的变量</strong>。</p><p>Java<strong>接口中的成员函数默认是public的</strong>。<strong>抽象类的成员函数可以是private，protected或者是public</strong>。</p><p>接口是绝对抽象的，<strong>不可以被实例化</strong>，抽象类也<strong>不可以被实例化</strong>。</p><h3 id="7-进程和线程的区别是什么？"><a href="#7-进程和线程的区别是什么？" class="headerlink" title="7. 进程和线程的区别是什么？"></a>7. 进程和线程的区别是什么？</h3><p><strong>进程是执行着的应用程序，而线程是进程内部的一个执行序列</strong>。<strong>一个进程可以有多个线程</strong>。线程又叫做轻量级进程。</p><p>线程与进程的区别归纳：</p><p>a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p><p>b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p><p>c.调度和切换：线程上下文切换比进程上下文切换要快得多。</p><p>d.在多线程OS中，进程不是一个可执行的实体。</p><h3 id="8-概括的解释下线程的几种可用状态。"><a href="#8-概括的解释下线程的几种可用状态。" class="headerlink" title="8. 概括的解释下线程的几种可用状态。"></a>8. 概括的解释下线程的几种可用状态。</h3><ol><li><p><strong>新建</strong>( new )：新创建了一个线程对象。</p></li><li><p><strong>可运行</strong>( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权 。</p></li><li><p><strong>运行</strong>( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</p></li><li><p><strong>阻塞</strong>( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：</p></li></ol><p>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。</p><p>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。</p><p>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</p><ol start="5"><li><strong>死亡</strong>( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ol><img src="/2020/09/02/Java%E6%96%B9%E5%90%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%8F%8A%E7%BB%93%E6%9E%84-java-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/thread.png" class="" title="thread"><h3 id="9-同步方法和同步代码块的区别是什么？"><a href="#9-同步方法和同步代码块的区别是什么？" class="headerlink" title="9. 同步方法和同步代码块的区别是什么？"></a>9. 同步方法和同步代码块的区别是什么？</h3><p>区别：</p><p>同步方法默认用<strong>this或者当前类class对象</strong>作为锁；</p><p>同步代码块<strong>可以选择以什么来加锁</strong>，比同步方法要<strong>更细颗粒度</strong>，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p><p>同步方法<strong>使用关键字</strong> synchronized修饰方法，而同步代码块主要是<strong>修饰需要进行同步的代码</strong>，用   synchronized（object）{代码内容}进行修饰；</p><h3 id="10-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#10-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="10. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>10. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><p>监视器和锁在Java虚拟机中是一块使用的。</p><p>监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。</p><p>每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p><p>16</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库死锁排查</title>
      <link href="/2020/08/28/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5/"/>
      <url>/2020/08/28/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><ol><li>查询是否锁表</li></ol><p>show open tables where in_use &gt; 0;</p><a id="more"></a><ol start="2"><li>查询进程（如果您有super权限，您可以看到所有线程。否则，您只能看到您自己的线程）</li></ol><p>show processlist</p><ol start="3"><li>杀死进程id（就是上面命令的id列）</li></ol><p>kill id</p><h3 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h3><ol><li>查看下在锁的事务</li></ol><p>select * from information_schema.innodb_trx;</p><ol start="2"><li>杀死进程id（就是上面命令的trx_mysql_thread_id列）</li></ol><p>kill 线程id</p><p><strong>例子：</strong></p><p>查出死锁进程：show processlist</p><p>杀掉进程 kill 420821;</p><p><strong>其它关于查看死锁的命令：</strong></p><p>1：查看当前的事务</p><p>select * from information_schema.innodb_trx;</p><p>2：查看当前锁定的事务</p><p>select * from information_schema.innodb_locks;</p><p>3：查看当前等锁的事务</p><p>select * from information_schema.innodb_lock_waits;</p><h3 id="第三种："><a href="#第三种：" class="headerlink" title="第三种："></a>第三种：</h3><p>show engine innodb status</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>链接：<a href="https://www.jianshu.com/p/624c3403bb2a" target="_blank" rel="noopener">https://www.jianshu.com/p/624c3403bb2a</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三句话搞懂Redis-缓存穿透、击穿、雪崩</title>
      <link href="/2020/08/28/%E4%B8%89%E5%8F%A5%E8%AF%9D%E6%90%9E%E6%87%82Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/"/>
      <url>/2020/08/28/%E4%B8%89%E5%8F%A5%E8%AF%9D%E6%90%9E%E6%87%82Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如何有效的理解并且区分 Redis <strong>穿透、击穿和雪崩</strong>之间的区别，一直以来都挺困扰我的。特别是穿透和击穿，过一段时间就稀里糊涂的分不清了。</p><p>为了有效的帮助自己，以及拥有同样烦恼的朋友们区分这三种场景。我总结了一些关键词，希望大家可以和我一样通过联想的方式来区分并理解这三种场景的区别！</p><a id="more"></a><h3 id="一-缓存穿透"><a href="#一-缓存穿透" class="headerlink" title="一. 缓存穿透"></a>一. 缓存穿透</h3><h4 id="关键词：穿过-Redis-和数据库"><a href="#关键词：穿过-Redis-和数据库" class="headerlink" title="关键词：穿过 Redis 和数据库"></a>关键词：穿过 Redis 和数据库</h4><p>当 Redis 和数据库中都没有我们想要的数据时，就需要考虑缓存穿透的问题了。下面这段逻辑大家用的会比较多：先去 Redis 中查找某资源，Redis 中查不到就去 DB 中查，DB 中查到后回写一份数据到 Redis 中。</p><img src="/2020/08/28/%E4%B8%89%E5%8F%A5%E8%AF%9D%E6%90%9E%E6%87%82Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/chuantou.png" class="" title="缓存穿透"><p>这段逻辑正常情况下问题并不大，但是如果用户恶意重复请求资源 X，该资源在 Redis 和 DB 中都不存在。那么每次请求都会直接打到 DB 上，甚至导致物理 DB 宕机。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><strong>缓存空结果</strong></li></ol><p>如果系统发现 Redis 及 DB 中都不存在该资源，就缓存空结果一段时间。需要注意哈，这次的失效时间不能设置的太长，否则数据的实效性会产生很大的问题。</p><ol start="2"><li><strong>用户合法性校验</strong></li></ol><p>对用户的请求合法性进行校验，拦截恶意重复请求。</p><ol start="3"><li><strong>布隆过滤器</strong></li></ol><p>看到这个名词不要慌。简单来说布隆过滤器的用途就是帮助你判断某个值是否存在。</p><p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>把数据库中的数据的key都在布隆过滤器中过一遍，能帮助我们挡掉大部分不存在的key的请求</p><h3 id="二-缓存击穿"><a href="#二-缓存击穿" class="headerlink" title="二. 缓存击穿"></a>二. 缓存击穿</h3><h4 id="关键词：定点打击"><a href="#关键词：定点打击" class="headerlink" title="关键词：定点打击"></a>关键词：定点打击</h4><p>试想如果所有请求对着一个 key 照死里搞，这是不是就是一种定点打击呢？</p><p>怎么理解呢？举个极端的例子：比如某某明星爆出一个惊天狠料，海量吃瓜群众同时访问微博去查看该八卦新闻，而微博 Redis 集群中数据在此刻正好过期了，那么无数的请求则直接打到了微博系统的物理 DB 上，DB 瞬间挂了。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><strong>热点数据永远不过期</strong></li></ol><p>比如我们可以将某个 key 的缓存时间设置为 25 小时，然后后台有个 JOB 每隔 24 小时就去批量刷新一下热点数据。就可以解决这个问题了。</p><ol start="2"><li><strong>使用互斥锁</strong></li></ol><p>容易影响吞吐量，大部分项目设置热点 key 永不过期就妥妥的了。</p><h3 id="三-缓存雪崩"><a href="#三-缓存雪崩" class="headerlink" title="三. 缓存雪崩"></a>三. 缓存雪崩</h3><h4 id="关键词：Redis-崩了，没有数据了"><a href="#关键词：Redis-崩了，没有数据了" class="headerlink" title="关键词：Redis 崩了，没有数据了"></a>关键词：Redis 崩了，没有数据了</h4><p>这里的 Redis 崩了指的并不是 Redis 集群宕机了。而是说在某个时刻 Redis 集群中的热点 key 都失效了。如果集群中的热点 key 在某一时刻同时失效了的话，试想海量的请求都将直接打到 DB 上，DB 可能在瞬间就被打爆了。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><strong>Redis 失效时间加上随机数</strong></li></ol><p>Redis 失效时间加上随机数，是一种比较取巧的解决方案。在一定程度上减轻了 DB 的瞬时压力，但是这种方案也在一定程度上增加了维护的成本。</p><ol start="2"><li><strong>Redis 永不过期</strong></li></ol><p>实现方案在上文中简单提过了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后我们再回归到主题！如何轻松的通过联想的方式来区分 Redis 缓存穿透、击穿、雪崩的区别？</p><ul><li><p><strong>缓存穿透</strong>—穿过（绕过） Redis 和 DB 来搞你</p></li><li><p><strong>缓存击穿</strong>—定点打击来搞你</p></li><li><p><strong>缓存雪崩</strong>—热点 key 在某一个时刻同时失效</p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s/AmxDAhbUpO0awG5mieyAjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AmxDAhbUpO0awG5mieyAjQ</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合分布式任务调度平台XXL-JOB</title>
      <link href="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/"/>
      <url>/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/</url>
      
        <content type="html"><![CDATA[<h2 id="XXL-JOB简要介绍"><a href="#XXL-JOB简要介绍" class="headerlink" title="XXL-JOB简要介绍"></a>XXL-JOB简要介绍</h2><p>XXL-JOB是一个轻量级分布式任务调度平台，其实现原理是：调度中心会配置 cron表达式，路由策略，处理类的bean实例，执行器需要向调度中心发生心跳，对于长时间没有收到心跳的执行器，调度中心会将其剔除</p><p>其中在高可用过程中xxl-job-admin是通过xxl_job_qrtz_locks表来竞争数据库锁保证多个调度中心分发任务只分发一次</p><a id="more"></a><p>下面是XXL-JOB的架构图：</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/jiagou.png" class="" title="架构图"><h2 id="搭建admin"><a href="#搭建admin" class="headerlink" title="搭建admin"></a>搭建admin</h2><h3 id="clone源码并初始化数据库"><a href="#clone源码并初始化数据库" class="headerlink" title="clone源码并初始化数据库"></a>clone源码并初始化数据库</h3><p>项目github地址 ： <a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">https://github.com/xuxueli/xxl-job</a></p><p>首先git clone下来项目</p><p>源码结构：</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/yuanma.png" class="" title="源码结构"><p>之后再doc中找到sql文件，在数据库中执行，初始化数据库：</p><p>执行完毕，会在MySQL数据库中生成如下 8 张表：</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/tables.png" class="" title="数据库表"><h3 id="配置调度中心"><a href="#配置调度中心" class="headerlink" title="配置调度中心"></a>配置调度中心</h3><p>调度中心就是源码中的 <strong>xxl-job-admin</strong> 工程，我们需要将其配置成自己需要的调度中心，通过该工程我们能够以图形化的方式统一管理任务调度平台上调度任务，负责触发调度执行。</p><h4 id="1-修改调度中心配置文件"><a href="#1-修改调度中心配置文件" class="headerlink" title="1. 修改调度中心配置文件"></a>1. 修改调度中心配置文件</h4><p>其他的保持一致即可，只需要修改下面几个地方：</p><h5 id="数据库相关："><a href="#数据库相关：" class="headerlink" title="数据库相关："></a>数据库相关：</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### xxl-job, datasource</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://101.23.63.118:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=AC7c</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h5 id="添加管理界面的用户名和密码："><a href="#添加管理界面的用户名和密码：" class="headerlink" title="添加管理界面的用户名和密码："></a>添加管理界面的用户名和密码：</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 管理界面的登录用户名密码</span></span><br><span class="line"><span class="string">xxl.job.login.username=admin</span></span><br><span class="line"><span class="string">xxl.job.login.password=123456</span></span><br></pre></td></tr></table></figure><h4 id="2-运行调度中心"><a href="#2-运行调度中心" class="headerlink" title="2. 运行调度中心"></a>2. 运行调度中心</h4><p>xxl-job-admin工程是一个springboot项目，直接运行项目即可</p><h4 id="3-访问调度中心管理界面"><a href="#3-访问调度中心管理界面" class="headerlink" title="3. 访问调度中心管理界面"></a>3. 访问调度中心管理界面</h4><p>在浏览器输入 <a href="http://localhost:8080/xxl-job-admin" target="_blank" rel="noopener">http://localhost:8080/xxl-job-admin</a> 然后输入用户名和密码（前面配置文件中配置的），即可看到如下管理界面。</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/interface.png" class="" title="管理界面"><h2 id="创建执行器项目"><a href="#创建执行器项目" class="headerlink" title="创建执行器项目"></a>创建执行器项目</h2><p>其实在源码中，作者提供了各个版本的 执行器项目，下面我以创建一个 springboot 版本的执行器为例来介绍。</p><p>一定要阅读项目中作者给的demo，要不然吃大亏！！ （否则调试半天还是报错</p><h3 id="1-添加Maven依赖"><a href="#1-添加Maven依赖" class="headerlink" title="1. 添加Maven依赖"></a>1. 添加Maven依赖</h3><p>查看demo中的版本是2.2.1-SNAPSHOT，这是一个本地的jar包</p><p>所以我们就使用maven repository官网和他最接近的版本，也就是2.2.0</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xxl-rpc-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-配置config文件"><a href="#2-配置config文件" class="headerlink" title="2. 配置config文件"></a>2. 配置config文件</h3><p>直接从demo中将config文件copy过来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxlJobConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(XxlJobConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.admin.addresses&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.accessToken&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.appname&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.address&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.ip&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.logpath&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.logretentiondays&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XxlJobSpringExecutor <span class="title">xxlJobExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init."</span>);</span><br><span class="line">        XxlJobSpringExecutor xxlJobSpringExecutor = <span class="keyword">new</span> XxlJobSpringExecutor();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对多网卡、容器内部署等情况，可借助 "spring-cloud-commons" 提供的 "InetUtils" 组件灵活定制注册IP；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      1、引入依赖：</span></span><br><span class="line"><span class="comment">     *          &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">     *             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">     *             &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">     *             &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">     *         &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      2、配置文件，或者容器启动变量</span></span><br><span class="line"><span class="comment">     *          spring.cloud.inetutils.preferred-networks: 'xxx.xxx.xxx.'</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      3、获取IP</span></span><br><span class="line"><span class="comment">     *          String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="comment">#调度中心部署跟地址：如调度中心集群部署存在多个地址则用逗号分隔。</span></span><br><span class="line">      <span class="comment">#执行器将会使用该地址进行"执行器心跳注册"和"任务结果回调"。</span></span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://192.168.31.79:8080/xxl-job-admin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#分别配置执行器的名称、ip地址、端口号</span></span><br><span class="line">    <span class="comment">#注意：如果配置多个执行器时，防止端口冲突</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">executorDemo</span></span><br><span class="line">      <span class="attr">address:</span></span><br><span class="line">      <span class="attr">ip:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">#执行器运行日志文件存储的磁盘位置，需要对该路径拥有读写权限</span></span><br><span class="line">      <span class="attr">logpath:</span> <span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line">      <span class="comment">#执行器Log文件定期清理功能，指定日志保存天数，日志文件过期自动删除。限制至少保持3天，否则功能不生效；</span></span><br><span class="line">      <span class="comment">#-1表示永不删除</span></span><br><span class="line">      <span class="attr">logretentiondays:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">accessToken:</span></span><br></pre></td></tr></table></figure><p>注意这里的 appname: executorDemo 要和管理界面中的appName对应</p><p><strong>注意注意</strong>：这里的addresses尽量别写127.0.0.1，尽量换成自己电脑的ip， 反正我用127.0.0.1是注册不上的。</p><h3 id="3-创建执行器"><a href="#3-创建执行器" class="headerlink" title="3. 创建执行器"></a>3. 创建执行器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobHandlerDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob</span>(<span class="string">"demoJobHandler"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">execute</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XxlJobLogger.log(<span class="string">"XXL-JOB, Hello World."</span>);</span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的 @XxlJob(“demoJobHandler”) 这个名称要和管理界面的JobHandler名称一致</p><h2 id="在调度中心中配置执行器"><a href="#在调度中心中配置执行器" class="headerlink" title="在调度中心中配置执行器"></a>在调度中心中配置执行器</h2><h3 id="1-配置执行器"><a href="#1-配置执行器" class="headerlink" title="1. 配置执行器"></a>1. 配置执行器</h3><p>点击  执行器管理—-》新增执行器—》，如下如下界面，然后填充此表格，点击保存即可。</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/executor.png" class="" title="配置执行器"><p>下面是对这几个参数的介绍：</p><ul><li><p>AppName：是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用;</p></li><li><p>名称：执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性;</p></li><li><p>排序: 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表;</p></li><li><p>注册方式：调度中心获取执行器地址的方式，</p></li></ul><p>　　　　自动注册：执行器自动进行执行器注册，调度中心通过底层注册表可以动态发现执行器机器地址；</p><p>　　　　手动录入：人工手动录入执行器的地址信息，多地址逗号分隔，供调度中心使用；</p><ul><li>机器地址：”注册方式”为”手动录入”时有效，支持人工维护执行器的地址信息；</li></ul><h3 id="2-创建任务"><a href="#2-创建任务" class="headerlink" title="2. 创建任务"></a>2. 创建任务</h3><p>点击 任务管理—》新增任务—》</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/task.png" class="" title="创建任务"><ul><li><p>执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器, 可在 “执行器管理” 进行设置。</p></li><li><p>任务描述：任务的描述信息，便于任务管理；</p></li><li><p>路由策略：当执行器集群部署时，提供丰富的路由策略，包括；</p></li></ul><p>　　　　　　FIRST（第一个）：固定选择第一个机器；<br>　　　　　　LAST（最后一个）：固定选择最后一个机器；<br>　　　　　　ROUND（轮询）：；<br>　　　　　　RANDOM（随机）：随机选择在线的机器；<br>　　　　　　CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。<br>　　　　　　LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；<br>　　　　　　LEAST_RECENTLY_USED（最近最久未使用）：最久为使用的机器优先被选举；<br>　　　　　　FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；<br>　　　　　　BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；<br>　　　　　　SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</p><ul><li><p>Cron：触发任务执行的Cron表达式；</p></li><li><p>运行模式：</p></li></ul><p>　　　　　　BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务；<br>　　　　　　GLUE模式(Java)：任务以源码方式维护在调度中心；该模式的任务实际上是一段继承自IJobHandler的Java类代码并 “groovy” 源码方式维护，它在执行器项目中运行，可使用@Resource/@Autowire注入执行器里中的其他服务；<br>　　　　　　GLUE模式(Shell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “shell” 脚本；<br>　　　　　　GLUE模式(Python)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “python” 脚本；<br>　　　　　　GLUE模式(PHP)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “php” 脚本；<br>　　　　　　GLUE模式(NodeJS)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “nodejs” 脚本；<br>　　　　　　GLUE模式(PowerShell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “PowerShell” 脚本；</p><ul><li><p>JobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值；</p></li><li><p>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；</p></li></ul><p>　　　　　　单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；<br>　　　　　　丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；<br>　　　　　　覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</p><ul><li><p>子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度。</p></li><li><p>任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；</p></li><li><p>失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；</p></li><li><p>报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔；</p></li><li><p>负责人：任务的负责人；</p></li><li><p>执行参数：任务执行所需的参数，多个参数时用逗号分隔，任务执行时将会把多个参数转换成数组传入；</p></li></ul><h2 id="启动任务"><a href="#启动任务" class="headerlink" title="启动任务"></a>启动任务</h2><p>分别运行admin项目和执行器项目</p><p>运行执行器项目之后可以在管理界面上的执行器管理看到注册的机器地址：</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/address.png" class="" title="机器地址"><p>之后启动任务，就可以运行了：</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/start.png" class="" title="启动任务"><p>可以查看日志，查看运行情况：</p><img src="/2020/08/28/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB/log.png" class="" title="查看日志"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样就大功告成啦 </p><p>详细的教程可以查看作者的中文教程 ： <a href="https://www.xuxueli.com/xxl-job/#%20" target="_blank" rel="noopener">https://www.xuxueli.com/xxl-job/#%20</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ecf7d2c7de9d" target="_blank" rel="noopener">https://www.jianshu.com/p/ecf7d2c7de9d</a></p><p><a href="https://www.cnblogs.com/ysocean/p/10541151.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/10541151.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中-Async的用法与实践</title>
      <link href="/2020/08/27/SpringBoot%E4%B8%AD-Async%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/08/27/SpringBoot%E4%B8%AD-Async%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务。其实，在Spring 3.x之后，就已经内置了@Async来完美解决这个问题，本文将完成介绍@Async的用法。</p><a id="more"></a><h3 id="Async的使用"><a href="#Async的使用" class="headerlink" title="@Async的使用"></a>@Async的使用</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>必须用在public方法上，且不能是static方法</li><li>不能与调用的方法在同一个类中</li><li>需要把该方法注入到Spring容器中，就是在一个类中添加异步方法，并在此类上使用@Component之类的注解加入到容器</li></ul><h4 id="注解配置开启"><a href="#注解配置开启" class="headerlink" title="注解配置开启"></a>注解配置开启</h4><p>在springboot启动类上添加 <strong>@EnableAsync</strong> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CupidApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><h4 id="基于-Async无返回值调用"><a href="#基于-Async无返回值调用" class="headerlink" title="基于@Async无返回值调用"></a>基于@Async无返回值调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有返回值的Async方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethodWithVoidReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"没有返回值的Async方法, ThreadName : &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用的方式非常简单，一个标注即可解决所有的问题。</p><p>调用结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-27 11:52:31.197  INFO 7311 --- [         task-5] c.w.cupid.service.impl.AsyncServiceImpl  : 没有返回值的Async方法, ThreadName : task-5</span><br></pre></td></tr></table></figure><h4 id="基于-Async返回值的调用"><a href="#基于-Async返回值的调用" class="headerlink" title="基于@Async返回值的调用"></a>基于@Async返回值的调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有返回值的Async方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    Future    new AsyncResult</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">asyncMethodWithReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"有返回值的Async方法, ThreadName : &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;String&gt;(<span class="string">"hello world !!!!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"出问题了, &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上示例可以发现，返回的数据类型为Future类型，其为一个接口。具体的结果类型为<strong>AsyncResult</strong>，这个是需要注意的地方。</p><p>调用返回结果的异步方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/future"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">futureAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"Invoking an asynchronous method. threadName : "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; stringFuture = asyncService.asyncMethodWithReturnType();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stringFuture.isDone()) &#123;</span><br><span class="line">                stringBuilder.append(<span class="string">"Result from asynchronous process - "</span> + stringFuture.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(<span class="string">"Continue doing something else."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析： 这些获取异步方法的结果信息，是通过不停的检查Future的状态来获取当前的异步方法是否执行完毕来实现的。</p><h3 id="给-Async使用自定义的线程池"><a href="#给-Async使用自定义的线程池" class="headerlink" title="给@Async使用自定义的线程池"></a>给@Async使用自定义的线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * logger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ThreadPoolConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;asyncThreadPool.corePoolSize&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;asyncThreadPool.maxPoolSize&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;asyncThreadPool.queueCapacity&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;asyncThreadPool.keepAliveSeconds&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;asyncThreadPool.awaitTerminationSeconds&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> awaitTerminationSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;asyncThreadPool.threadNamePrefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.util.concurrent.Executor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> wliduo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019/2/15 14:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"threadPoolTaskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">threadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---------- 线程池开始加载 ----------"</span>);</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">// 核心线程池大小</span></span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 最大线程数</span></span><br><span class="line">        threadPoolTaskExecutor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 队列容量</span></span><br><span class="line">        threadPoolTaskExecutor.setQueueCapacity(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 活跃时间</span></span><br><span class="line">        threadPoolTaskExecutor.setKeepAliveSeconds(queueCapacity);</span><br><span class="line">        <span class="comment">// 主线程等待子线程执行时间</span></span><br><span class="line">        threadPoolTaskExecutor.setAwaitTerminationSeconds(awaitTerminationSeconds);</span><br><span class="line">        <span class="comment">// 线程名字前缀</span></span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        <span class="comment">// RejectedExecutionHandler:当pool已经达到max-size的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CallerRunsPolicy:不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">        threadPoolTaskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        threadPoolTaskExecutor.initialize();</span><br><span class="line">        logger.info(<span class="string">"---------- 线程池加载完成 ----------"</span>);</span><br><span class="line">        <span class="keyword">return</span> threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用自定义的线程池"><a href="#使用自定义的线程池" class="headerlink" title="使用自定义的线程池"></a>使用自定义的线程池</h4><p>@Async(“threadPoolTaskExecutor”)</p><p>只需要在 @Async 注解的括号里加上自定义的线程池的bean即可</p><h3 id="Async调用中的事务处理机制"><a href="#Async调用中的事务处理机制" class="headerlink" title="@Async调用中的事务处理机制"></a>@Async调用中的事务处理机制</h3><p>在@Async标注的方法，同时也适用了@Transactional进行了标注；在其调用数据库操作之时，将无法产生事务管理的控制，原因就在于其是基于异步处理的操作。</p><p>那该如何给这些操作添加事务管理呢？可以将需要事务管理操作的方法放置到异步方法内部，在内部被调用的方法上添加@Transactional。</p><p>例如：</p><p>方法A，使用了@Async/@Transactional来标注，但是无法产生事务控制的目的。</p><p>方法B，使用了@Async来标注，B中调用了C、D。C/D分别使用@Transactional做了标注，则可实现事务控制的目的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/0e61693860b7?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="noopener">https://www.jianshu.com/p/0e61693860b7?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends</a></p><p><a href="https://blog.csdn.net/zhuyu19911016520/article/details/99992668" target="_blank" rel="noopener">https://blog.csdn.net/zhuyu19911016520/article/details/99992668</a></p><p><a href="https://www.jianshu.com/p/49b9d15456d9?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="noopener">https://www.jianshu.com/p/49b9d15456d9?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal实践与详解</title>
      <link href="/2020/08/26/ThreadLocal%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/26/ThreadLocal%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ThreadLocal类是用来提供线程内部的局部变量。让这些变量在多线程环境下访问（get/set）时能保证各个线程里的变量相对独立于其他线程内的变量。</p><p>ThreadLocal是一个关于创建线程局部变量的类。</p><p>通常情况下，我们创建的成员变量都是线程不安全的。因为他可能被多个线程同时修改，此变量对于多个线程之间彼此并不独立，是共享变量。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程无法访问和修改。也就是说：将线程公有化变成线程私有化。</p><a id="more"></a><h3 id="应用和实践"><a href="#应用和实践" class="headerlink" title="应用和实践"></a>应用和实践</h3><p>每个线程都需要一个独享的对象（比如工具类，典型的就是SimpleDateFormat，每次使用都new一个多浪费性能呀，直接放到成员变量里又是线程不安全，所以把他用ThreadLocal管理起来就完美了。）</p><p>现在放到 springboot 工程中创建一个test类进行举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * 用<span class="title">SimpleDateFormat</span>测试<span class="title">threadLocal</span>的使用</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStr</span><span class="params">(<span class="keyword">int</span> millisSeconds)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(millisSeconds);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> simpleDateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                String date = dateToStr(j * <span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 从结果中可以看出是线程安全的，时间没有重复的。</span></span><br><span class="line">                log.info(date);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeFormatter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">                ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的朋友已经发现了，这TM也是每个线程都创建一个SimpleDateFormat啊，跟直接在方法内部new没区别，错了，大错特错！</p><p><strong>1个请求进来是一个线程</strong>，他可能贯穿了N个方法，你这N个方法假设有3个都在使用dateToStr()，你直接new的话会产生三个SimpleDateFormat对象，而用ThreadLocal的话只会产生一个对象，一个线程一个。</p><p><strong>每个线程内需要保存全局变量（比如在登录成功后将用户信息存到ThreadLocal里，然后当前线程操作的业务逻辑直接get取就完事了，有效的避免的参数来回传递的麻烦之处），一定层级上减少代码耦合度。</strong></p><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><p>每个Thread对象中都持有一个ThreadLocalMap的成员变量。</p><p>每个ThreadLocalMap内部又维护了N个Entry节点，也就是Entry数组，每个Entry代表一个完整的对象，</p><p>key是ThreadLocal本身，value是ThreadLocal的泛型值。</p><p>下面是核心源码：</p><img src="/2020/08/26/ThreadLocal%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%AF%A6%E8%A7%A3/class.png" class="" title="类关系"><h4 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h4><img src="/2020/08/26/ThreadLocal%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%AF%A6%E8%A7%A3/class_ref.png" class="" title="类关系图"><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ul><li><p><strong>initialValue</strong>：初始化。在get方法里<strong>懒加载</strong>的。</p></li><li><p><strong>get</strong>：得到这个线程对应的value。如果调用get之前没set过，则get内部会执行initialValue方法进行初始化。</p></li><li><p><strong>set</strong>：为这个线程设置一个新值。</p></li><li><p><strong>remove</strong>：删除这个线程对应的值，<strong>防止内存泄露</strong>的最佳手段。</p></li></ul><h5 id="1-initialValue"><a href="#1-initialValue" class="headerlink" title="1. initialValue"></a>1. initialValue</h5><p>见名知意，初始化一些value（泛型值）。懒加载的。</p><p>触发时机 ： 调用get方法之前没有调用set方法，则get方法内部会触发initialValue，也就是说get的时候如果没拿到东西，则会触发initialValue。</p><p>通常，每个线程最多调用一次此方法。但是如果已经调用了remove()，然后再次调用get()的话，则可以再次触发initialValue。</p><p>如果要重写的话一般建议采取匿名内部类的方式重写此方法，否则默认返回的是null。</p><p>两种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Java8的高逼格写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>));</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由子类提供实现。</span></span><br><span class="line"><span class="comment">// protected的含义就是交给子类干的。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-get"><a href="#2-get" class="headerlink" title="2. get"></a>2. get</h5><p>获取当前线程下的ThreadLocal中的值。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程下的entry里的value值。</span></span><br><span class="line"><span class="comment"> * 先获取当前线程下的ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 然后以当前ThreadLocal为key取出map中的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap对象。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取此ThreadLocalMap下的entry对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 若entry也获取到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">// 直接获取entry对应的value返回。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。</span></span><br><span class="line">    <span class="comment">// 知识点：我早就说了，初始值方法是延迟加载，只有在get才会用到，这下看到了吧，只有在这获取没获取到才会初始化，下次就肯定有值了，所以只会执行一次！！！</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-set"><a href="#3-set" class="headerlink" title="3. set"></a>3. set</h5><p>其实干的事和initialValue是一样的，都是set值，只是调用时机不同。set是想用就用，api摆在这里，你想用就调一下set方法。很自由。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程的线程局部变量的值</span></span><br><span class="line"><span class="comment"> * 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap实例，注意这里是将t传进去了，t是当前线程，就是说ThreadLocalMap是在线程里持有的引用。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-remove"><a href="#4-remove" class="headerlink" title="4. remove"></a>4. remove</h5><p>将当前线程下的ThreadLocal的值删除，目的是为了减少内存占用。主要目的是防止<strong>内存泄漏</strong>。内存泄漏问题下面会说。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程局部变量的值删除，目的是为了减少内存占用。主要目的是防止内存泄漏。内存泄漏问题下面会说。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象，并将其移除。</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 直接移除以当前ThreadLocal为key的value</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-和Synchronized的区别"><a href="#1-和Synchronized的区别" class="headerlink" title="1. 和Synchronized的区别"></a>1. 和Synchronized的区别</h4><p>问：他和线程同步机制（如：Synchronized）提供一样的功能，这个很吊啊。</p><p>答：否！同步机制保证的是多线程同时操作共享变量并且能正确的输出结果。ThreadLocal不行啊，他把共享变量变成线程私有了，每个线程都有独立的一个变量。举个通俗易懂的案例：网站计数器，你给变量count++的时候带上synchronized即可解决。ThreadLocal的话做不到啊，他没发统计，他只能说能统计每个线程登录了多少次。</p><h4 id="2-存储在jvm的哪个区域"><a href="#2-存储在jvm的哪个区域" class="headerlink" title="2. 存储在jvm的哪个区域"></a>2. 存储在jvm的哪个区域</h4><p>问：线程私有，那么就是说ThreadLocal的实例和他的值是放到栈上咯？</p><p>答：不是。还是在堆的。ThreadLocal对象也是对象，对象就在堆。只是JVM通过一些技巧将其可见性变成了线程可见。</p><h4 id="3-会导致内存泄漏么-重点！！！"><a href="#3-会导致内存泄漏么-重点！！！" class="headerlink" title="3. 会导致内存泄漏么 重点！！！"></a>3. 会导致内存泄漏么 重点！！！</h4><p>问：会导致内存泄漏么？</p><p>答：分析一下：</p><p>1、ThreadLocalMap.Entry的key会内存泄漏吗？</p><p>2、ThreadLocalMap.Entry的value会内存泄漏吗？</p><p>先看下key-value的核心源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看继承关系，发现是继承了弱引用，而且key直接是交给了父类处理super(key)，父类是个弱引用，所以key完全不存在内存泄漏问题，因为他不是强引用，它可以被GC回收的。</p><p>弱引用的特点：如果这个对象只被弱引用关联，没有任何强引用关联，那么这个对象就可以被GC回收掉。弱引用不会阻止GC回收。这是jvm知识。</p><p>再看value，发现value是个强引用，但是想了下也没问题的呀，因为线程终止了，我管你强引用还是弱引用，都会被GC掉的，因为引用链断了（jvm用的可达性分析法，线程终止了，根节点就断了，下面的都会被回收）。</p><p>这么分析一点毛病都没有，但是忘了一个主要的角色，那就是线程池，线程池的存在核心线程是不会销毁的，只要创建出来他会反复利用，生命周期不会结束掉，但是key是弱引用会被GC回收掉，value强引用不会回收，所以形成了如下场面：</p><p><strong>Thread-&gt;ThreadLocalMap-&gt;Entry(key为null)-&gt;value</strong></p><p>由于value和Thread还存在链路关系，还是可达的，所以不会被回收，这样越来越多的垃圾对象产生却无法回收，造成内存泄漏，时间久了必定OOM。</p><p><strong>解决方案</strong> ThreadLocal已经为我们想好了，提供了remove()方法，这个方法是将value移出去的。所以用完后记得remove()。</p><h4 id="4-你学习的开源框架哪些用到了ThreadLocal"><a href="#4-你学习的开源框架哪些用到了ThreadLocal" class="headerlink" title="4. 你学习的开源框架哪些用到了ThreadLocal"></a>4. 你学习的开源框架哪些用到了ThreadLocal</h4><p>Spring框架。</p><p>DateTimeContextHolder</p><p>RequestContextHolder</p><h4 id="5-ThreadLocal里的对象一定是线程安全的吗"><a href="#5-ThreadLocal里的对象一定是线程安全的吗" class="headerlink" title="5. ThreadLocal里的对象一定是线程安全的吗"></a>5. ThreadLocal里的对象一定是线程安全的吗</h4><p>未必，如果在每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()获取的还是这个共享对象本身，还是有并发访问线程不安全问题。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s/ZqMkRXKeZ6QU-Imy3maYuQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZqMkRXKeZ6QU-Imy3maYuQ</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git版本回退方法</title>
      <link href="/2020/08/26/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%E6%96%B9%E6%B3%95/"/>
      <url>/2020/08/26/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>今天在公司犯了错误，在公司公共的develop分支上push了错误的代码，顺便研究了一下git如何回退版本，参考了大佬的做法，记录下了这篇博客。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果提交了一个错误的版本，怎么回退版本？</p><p>如果提交了一个错误的版本到远程分支，怎么回退远程分支版本？</p><p>如果提交了一个错误的版本到公共远程分支，又该怎么回退版本？</p><a id="more"></a><h3 id="本地分支版本回退的方法"><a href="#本地分支版本回退的方法" class="headerlink" title="本地分支版本回退的方法"></a>本地分支版本回退的方法</h3><p>如果你在本地做了错误提交，那么回退版本的方法很简单</p><p>先用下面命令找到要回退的版本的commit id：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>接着回退版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard Obfafd</span><br></pre></td></tr></table></figure><p>0bfafd就是你要回退的版本的commit id的前面几位</p><h3 id="自己的远程分支版本回退的方法"><a href="#自己的远程分支版本回退的方法" class="headerlink" title="自己的远程分支版本回退的方法"></a>自己的远程分支版本回退的方法</h3><p>如果你的错误提交已经推送到自己的远程分支了，那么就需要回滚远程分支了。<br>首先要回退本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard Obfafd</span><br></pre></td></tr></table></figure><p>紧接着强制推送到远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin develop</span><br></pre></td></tr></table></figure><p><strong>注意：本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支</strong></p><h3 id="公共远程分支版本回退的方法"><a href="#公共远程分支版本回退的方法" class="headerlink" title="公共远程分支版本回退的方法"></a>公共远程分支版本回退的方法</h3><p>使用git reset回退公共远程分支的版本后，需要其他所有人手动用远程master分支覆盖本地master分支，</p><p>显然，这不是优雅的回退方法，下面我们使用另个一个命令来回退版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD                     //撤销最近一次提交</span><br><span class="line">git revert HEAD~1                   //撤销上上次的提交，注意：数字从0开始</span><br><span class="line">git revert 0ffaacc                  //撤销0ffaacc这次提交</span><br></pre></td></tr></table></figure><p>git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是<strong>版本依然是向前的</strong>，</p><p>所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。</p><p>但是，要注意以下几点：</p><ol><li><p>revert 是撤销一次提交，所以后面的commit id是你需要回滚到的版本的前一次提交</p></li><li><p>使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的</p></li><li><p>使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。</p></li><li><p>如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了.</p></li></ol><p>git revert 命令的好处就是<strong>不会丢掉别人的提交</strong>，即使你撤销后覆盖了别人的提交，他更新代码后，可以在本地用 reset 向前回滚，找到自己的代码，然后拉一下分支，再回来合并上去就可以找回被你覆盖的提交了。</p><h3 id="继续扩展，简单粗暴的回滚方法"><a href="#继续扩展，简单粗暴的回滚方法" class="headerlink" title="继续扩展，简单粗暴的回滚方法"></a>继续扩展，简单粗暴的回滚方法</h3><p>看到这里也许你已经觉得学会了远程仓库版本回滚方法了，但是实践中总是会遇到很多不按套路来的问题，考虑下面一种情况：</p><p>如果你们开发中，忽然发现前面很远的地方有一次错误的合并代码，把本来下一次才能发的功能的代码合并到了这一次来了，这个时候全体成员都觉得直接回滚比较快，因为他们都有备份，覆盖了无所谓，这个时候用reset的话对队友的要求比较高，用revert的话呢要大面积的解决冲突，也很麻烦呀，怎么办呢？</p><p>这个时候，可以使用简单粗暴的办法，直接从那个错误的提交的前一次拉取一份代码放到其他目录，然后将master代码全部删除，把那份新代码方进去，然后提交，果然简单粗暴啊，虽然这种方法不入流，但是，实践中发现很好使啊，所以，实践是检验真理的唯一标准。遇到问题还是要灵活应对。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>远程分支回滚的三种方法：</p><ol><li><p>自己的分支回滚直接用reset</p></li><li><p>公共分支回滚用revert</p></li><li><p>错的太远了直接将代码全部删掉，用正确代码替代</p></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/fuchaosz/article/details/52170105" target="_blank" rel="noopener">http://blog.csdn.net/fuchaosz/article/details/52170105</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java编写单词小游戏</title>
      <link href="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>公司最近有一个竞技场项目，里面有一个单词小游戏。</p><p>游戏大概就是随机生成一个5*5的棋盘，上面有单词的字母，通过滑动连出正确的单词。</p><a id="more"></a><h2 id="棋盘生成算法"><a href="#棋盘生成算法" class="headerlink" title="棋盘生成算法"></a>棋盘生成算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先随机选个一个起点，从这个点开始铺单词。</p><p>分别选取上下左右四个方向作为下一个字母的摆放位置，不能触边也不能走重复路，直到平铺完所有的单词。</p><p>如果在棋盘能平铺下单词的情况下，找不到路径，就从四个角作为起点，必能找到路径。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/31 5:50 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateWordBoard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenerateWordBoard g = <span class="keyword">new</span> GenerateWordBoard();</span><br><span class="line">        g.generateCharBoard(<span class="string">"vocabulary"</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateCharBoard</span><span class="params">(String word, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单词为空 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (word.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单词长度大于棋盘 铺不下 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt; m * n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化棋盘 全为*</span></span><br><span class="line">        initBoard(m, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] wordChar = word.toCharArray();</span><br><span class="line">        <span class="comment">// 随机选取一个位置开始</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomX = random.nextInt(m);</span><br><span class="line">        <span class="keyword">int</span> randomY = random.nextInt(n);</span><br><span class="line">        <span class="comment">// 开始从随机位置dfs铺单词 从index 0 开始</span></span><br><span class="line">        <span class="keyword">boolean</span> result = generateDfs(board, wordChar, randomX, randomY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果没有找到路线 那么从四个角开始 必能找到一条路</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; starts = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, n - <span class="number">1</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m - <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m - <span class="number">1</span>, n - <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="comment">// 随机四个角的一个</span></span><br><span class="line">            Collections.shuffle(starts);</span><br><span class="line">            <span class="comment">// 初始化棋盘</span></span><br><span class="line">            initBoard(m, n);</span><br><span class="line">            <span class="comment">// dfs铺单词</span></span><br><span class="line">            generateDfs(board, wordChar, starts.get(<span class="number">0</span>)[<span class="number">0</span>], starts.get(<span class="number">0</span>)[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(board[i][j] + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBoard</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        board = <span class="keyword">new</span> <span class="keyword">char</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'*'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回true则为找到一条路 返回false为死路</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">generateDfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] wordChar, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 碰到边 或者碰到已经走过的位置 不能走了 死路</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 摆放一个字母</span></span><br><span class="line">        board[i][j] = wordChar[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果已经达到单词长度则直接返回 找到一条路</span></span><br><span class="line">        <span class="keyword">if</span> (index == wordChar.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前矩阵元素</span></span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        <span class="comment">// 修改为/ 表示已经访问过</span></span><br><span class="line">        board[i][j] = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上下左右四个方向开启递归</span></span><br><span class="line">        <span class="comment">// 查看能走几个方向 随机选择一个</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; directions = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        Collections.shuffle(directions);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; directions.size(); k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> di = i + directions.get(k)[<span class="number">0</span>], dj = j + directions.get(k)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">boolean</span> partialRes = generateDfs(board, wordChar, di, dj, index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                res = partialRes;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = res || partialRes;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果res为true 说明找到一条路 就不再遍历了 还原后返回true</span></span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                <span class="comment">// 还原矩阵元素</span></span><br><span class="line">                board[i][j] = tmp;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还原矩阵元素</span></span><br><span class="line">        board[i][j] = <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><div style="display: flex;flex-direction: row;justify-content: center;"><div style="width: 200px;height: 200px;"><img src="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/result1.png" class="" title="result1"></div><div style="width: 200px;height: 200px;"><img src="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/result2.png" class="" title="result2"></div><div style="width: 200px;height: 200px;"><img src="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/result3.png" class="" title="result3"></div><div style="width: 200px;height: 200px;"><img src="/2020/08/03/Java%E7%BC%96%E5%86%99%E5%8D%95%E8%AF%8D%E5%B0%8F%E6%B8%B8%E6%88%8F/result4.png" class="" title="result4"></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ControllerAdvice和ErrorController的用法</title>
      <link href="/2020/07/14/ControllerAdvice%E5%92%8CErrorController%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2020/07/14/ControllerAdvice%E5%92%8CErrorController%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Java中异常可以分为Error和Exception，<strong>@ControllerAdvice</strong>用来处理系统中的<strong>Exception</strong>，<strong>Error</strong>Controller处理系统中的<strong>Error</strong>。</p><a id="more"></a><h2 id="ErrorController"><a href="#ErrorController" class="headerlink" title="ErrorController"></a>ErrorController</h2><p>在项目中我们遇到404找不到的错误、或者500服务器错误都需要配置相应的页面给用户一个友好的提示，而在Spring Boot中我们需要如何设置。</p><p>当系统出现404或者405等错误信息时，springboot默认的访问路径为/error，所以实现ErrorController并重写。</p><h3 id="ErrorController源码"><a href="#ErrorController源码" class="headerlink" title="ErrorController源码"></a>ErrorController源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.web.servlet.error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marker interface used to indicate that a &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125; is used to</span></span><br><span class="line"><span class="comment"> * render errors. Primarily used to know the error paths that will not need to be secured.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the path of the error page.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the error path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getErrorPath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写ErrorController样例"><a href="#重写ErrorController样例" class="headerlink" title="重写ErrorController样例"></a>重写ErrorController样例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局Error/404处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> geekidea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiIgnore</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalErrorController</span> <span class="keyword">implements</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_PATH = <span class="string">"/error"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(ERROR_PATH)</span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;?&gt; handleError(HttpServletRequest request,HttpServletResponse response)&#123;</span><br><span class="line">        <span class="keyword">int</span> status = response.getStatus();</span><br><span class="line">        <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">            <span class="keyword">case</span> HttpServletResponse.SC_UNAUTHORIZED:</span><br><span class="line">                <span class="keyword">return</span> ApiResult.fail(ApiCode.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">case</span> HttpServletResponse.SC_FORBIDDEN:</span><br><span class="line">                <span class="keyword">return</span> ApiResult.fail(ApiCode.NOT_PERMISSION);</span><br><span class="line">            <span class="keyword">case</span> HttpServletResponse.SC_NOT_FOUND:</span><br><span class="line">                <span class="keyword">return</span> ApiResult.fail(ApiCode.NOT_FOUND);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.FAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"errorPath...."</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_PATH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>ControllerAdvice用来处理发生Exception错误的注解。需要注意的是不能使用try catch 捕获</p><h3 id="ControllerAdvice样例"><a href="#ControllerAdvice样例" class="headerlink" title="@ControllerAdvice样例"></a>@ControllerAdvice样例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> geekidea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非法参数验证异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.OK)</span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;List&lt;String&gt;&gt; handleMethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        BindingResult bindingResult = ex.getBindingResult();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors();</span><br><span class="line">        <span class="keyword">for</span> (FieldError fieldError : fieldErrors) &#123;</span><br><span class="line">            list.add(fieldError.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        log.error(getApiCodeString(ApiCode.PARAMETER_EXCEPTION) + <span class="string">":"</span> + JSON.toJSONString(list));</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.PARAMETER_EXCEPTION, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统登录异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = SysLoginException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">sysLoginExceptionHandler</span>(<span class="title">SysLoginException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.LOGIN_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.LOGIN_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HTTP解析请求参数异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = HttpMessageNotReadableException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">httpMessageNotReadableException</span>(<span class="title">HttpMessageNotReadableException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.PARAMETER_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.PARAMETER_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HTTP</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = HttpMediaTypeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">httpMediaTypeException</span>(<span class="title">HttpMediaTypeException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.HTTP_MEDIA_TYPE_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.HTTP_MEDIA_TYPE_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义业务/数据异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = &#123;SpringBootPlusException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">springBootPlusExceptionHandler</span>(<span class="title">SpringBootPlusException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        log.error(<span class="string">"springBootPlusException:"</span>, exception);</span><br><span class="line">        <span class="keyword">int</span> errorCode;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            errorCode = ApiCode.BUSINESS_EXCEPTION.getCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DaoException) &#123;</span><br><span class="line">            errorCode = ApiCode.DAO_EXCEPTION.getCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> VerificationCodeException) &#123;</span><br><span class="line">            errorCode = ApiCode.VERIFICATION_CODE_EXCEPTION.getCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errorCode = ApiCode.SPRING_BOOT_PLUS_EXCEPTION.getCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult&lt;Boolean&gt;()</span><br><span class="line">                .setCode(errorCode)</span><br><span class="line">                .setMessage(exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录授权异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = AuthenticationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">authenticationExceptionHandler</span>(<span class="title">AuthenticationException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.AUTHENTICATION_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.AUTHENTICATION_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未认证异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = UnauthenticatedException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">unauthenticatedExceptionHandler</span>(<span class="title">UnauthenticatedException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.UNAUTHENTICATED_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.UNAUTHENTICATED_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未授权异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = UnauthorizedException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">unauthorizedExceptionHandler</span>(<span class="title">UnauthorizedException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.UNAUTHORIZED_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.UNAUTHORIZED_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JWT Token解析异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = JWTDecodeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">jWTDecodeExceptionHandler</span>(<span class="title">JWTDecodeException</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.JWTDECODE_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.JWTDECODE_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = HttpRequestMethodNotSupportedException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">String</span>&gt; <span class="title">httpRequestMethodNotSupportedExceptionHandler</span>(<span class="title">Exception</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.HTTP_REQUEST_METHOD_NOT_SUPPORTED_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.HTTP_REQUEST_METHOD_NOT_SUPPORTED_EXCEPTION.getCode(), exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的异常处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span>&lt;<span class="title">Boolean</span>&gt; <span class="title">exceptionHandler</span>(<span class="title">Exception</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">        printRequestDetail();</span><br><span class="line">        printApiCodeException(ApiCode.SYSTEM_EXCEPTION, exception);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(ApiCode.SYSTEM_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印请求详情</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printRequestDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestDetail requestDetail = RequestDetailThreadLocal.getRequestDetail();</span><br><span class="line">        <span class="keyword">if</span> (requestDetail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"异常来源：ip: &#123;&#125;, path: &#123;&#125;"</span>, requestDetail.getIp(), requestDetail.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ApiCode格式化字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apiCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getApiCodeString</span><span class="params">(ApiCode apiCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apiCode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">"errorCode: %s, errorMessage: %s"</span>, apiCode.getCode(), apiCode.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印错误码及异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apiCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printApiCodeException</span><span class="params">(ApiCode apiCode, Exception exception)</span> </span>&#123;</span><br><span class="line">        log.error(getApiCodeString(apiCode), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jackson的使用</title>
      <link href="/2020/07/10/Jackson%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/10/Jackson%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近公司的竞技场项目中使用了jackson来进行java对象和json的相互转换</p><p>下面来介绍一下jackson的简单使用</p><a id="more"></a><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.6&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="第1步：创建ObjectMapper对象"><a href="#第1步：创建ObjectMapper对象" class="headerlink" title="第1步：创建ObjectMapper对象"></a>第1步：创建ObjectMapper对象</h3><p>创建ObjectMapper对象。它是一个可重复使用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br></pre></td></tr></table></figure><h3 id="第2步：反序列化JSON到对象"><a href="#第2步：反序列化JSON到对象" class="headerlink" title="第2步：反序列化JSON到对象"></a>第2步：反序列化JSON到对象</h3><p>从JSON对象使用readValue()方法来获取。通过JSON字符串和对象类型作为参数JSON字符串/来源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object to JSON Conversion</span></span><br><span class="line">Student student = mapper.readValue(jsonString, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="第3步：序列化对象到JSON"><a href="#第3步：序列化对象到JSON" class="headerlink" title="第3步：序列化对象到JSON"></a>第3步：序列化对象到JSON</h3><p>使用writeValueAsString()方法来获取对象的JSON字符串表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object to JSON Conversion</span></span><br><span class="line">jsonString = mapper.writeValueAsString(student);</span><br></pre></td></tr></table></figure><h2 id="信息配置-对mapper的设置"><a href="#信息配置-对mapper的设置" class="headerlink" title="信息配置 对mapper的设置"></a>信息配置 对mapper的设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在反序列化时忽略在 json 中存在但 Java 对象不存在的属性</span></span><br><span class="line">mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,</span><br><span class="line">   <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//在序列化时日期格式默认为 yyyy-MM-dd'T'HH:mm:ss.SSSZ</span></span><br><span class="line">mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,<span class="keyword">false</span>)</span><br><span class="line"><span class="comment">//在序列化时忽略值为 null 的属性</span></span><br><span class="line">mapper.setSerializationInclusion(Include.NON_NULL);</span><br><span class="line"><span class="comment">//忽略值为默认值的属性</span></span><br><span class="line">mapper.setDefaultPropertyInclusion(Include.NON_DEFAULT);</span><br></pre></td></tr></table></figure><h2 id="Jackson的注解的使用"><a href="#Jackson的注解的使用" class="headerlink" title="Jackson的注解的使用"></a>Jackson的注解的使用</h2><p>Jackson的常用注解</p><table><thead><tr><th>注解</th><th>用法</th></tr></thead><tbody><tr><td>@JsonProperty</td><td>用于属性，把属性的名称序列化时转换为另外一个名称。示例： @JsonProperty(“birth_ d ate”) private Date birthDate;</td></tr><tr><td>@JsonFormat</td><td>用于属性或者方法，把属性的格式序列化时转换成指定的格式。示例： @JsonFormat(timezone = “GMT+8”, pattern = “yyyy-MM-dd HH:mm” public Date getBirthDate()</td></tr><tr><td>@JsonPropertyOrder</td><td>用于类， 指定属性在序列化时 json 中的顺序 ， 示例： @JsonPropertyOrder({ “birth_Date”, “name” }) public class Person</td></tr><tr><td>@JsonCreator</td><td>用于构造方法，和 @JsonProperty 配合使用，适用有参数的构造方法。 示例： @JsonCreator public Person(@JsonProperty(“name”)String name) {…}</td></tr><tr><td>@JsonAnySetter</td><td>用于属性或者方法，设置未反序列化的属性名和值作为键值存储到 map 中 @JsonAnySetter public void set(String key, Object value) { map.put(key, value); }</td></tr><tr><td>@JsonIgnoreProperties</td><td>此注解是类注解，作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。 写法将此标签加在model 类的类名上 ，可以多个属性也可以单个属性</td></tr><tr><td>@JsonIgnore</td><td>用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。</td></tr><tr><td>@JsonSerialize</td><td>用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码，比如序列化一个double时在其后面限制两位小数点。</td></tr><tr><td>@JsonDeserialize</td><td>用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码，类似于上面的@JsonSerialize</td></tr><tr><td>@Transient</td><td>如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient，否则ORM框架默认其注解为@Basic；</td></tr></tbody></table><p>注： @JsonIgnore vs @Transient -difference?</p><img src="/2020/07/10/Jackson%E7%9A%84%E4%BD%BF%E7%94%A8/jack.png" class="" title="@JsonIgnore vs @Transient"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.yiibai.com/jackson" target="_blank" rel="noopener">https://www.yiibai.com/jackson</a></p><p><a href="https://developer.ibm.com/zh/articles/jackson-advanced-application/" target="_blank" rel="noopener">https://developer.ibm.com/zh/articles/jackson-advanced-application/</a></p><p><a href="https://blog.csdn.net/u012373815/article/details/52266609" target="_blank" rel="noopener">https://blog.csdn.net/u012373815/article/details/52266609</a></p><p><a href="https://stackoverflow.com/questions/29762328/jsonignore-vs-transient-difference/29762521#29762521?newreg=585c962710714560b6c3079b4b37850a" target="_blank" rel="noopener">https://stackoverflow.com/questions/29762328/jsonignore-vs-transient-difference/29762521#29762521?newreg=585c962710714560b6c3079b4b37850a</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化提高笔记</title>
      <link href="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于mysql的优化是一个综合性的技术，sql的优化只是其中的一种，其中主要包括</p><p>表的设计合理化(符合3大范式)。</p><p>添加索引(index) [普通索引、主键索引、唯一索引unique、全文索引]。</p><p>分表技术(水平分割、垂直分割)。</p><p>读写[写: update/delete/add]分离。</p><a id="more"></a><h2 id="合理设计表"><a href="#合理设计表" class="headerlink" title="合理设计表"></a>合理设计表</h2><p>在表的设计中一定条件下要满足三范式，表的范式，是首先符合第一范式, 才能满足第二范式 , 进一步满足第三范式。</p><p>第一范式: 即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只有数据库是关系型数据库(mysql/oracle/db2/sql server)，就自动的满足第一范式。</p><p>第二范式: 表中的记录是唯一的, 就满足第二范式, 通常我们设计一个主键来实现。</p><p>第三范式: 即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放. 比如下面的设计就是不满足第三范式：</p><img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/not_three.png" class="" title="not_three"><p>表1存在冗余表2的数据，正常的设计都会设计成如下：</p><img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/three.png" class="" title="three"><p>注意： 反第三范式: 但是没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。</p><p>在1对N的情况下，为了提高查询的效率，是允许部分字段冗余的。</p><p>提高效率而冗余的例子：</p><img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/example.png" class="" title="example"><p>这里是battle表，但是为了提高查询效率，将student_battle和class_battle的id分别都添加了，正常情况下应该battle-&gt;student_battle-&gt;class_battle</p><h2 id="Sql优化"><a href="#Sql优化" class="headerlink" title="Sql优化"></a>Sql优化</h2><p>Sql的优化中，主要是对字段添加索引，主要包含有这四种索引(主键索引/唯一索引/全文索引/普通索引)</p><h3 id="1-主键索引添加"><a href="#1-主键索引添加" class="headerlink" title="1.主键索引添加"></a>1.主键索引添加</h3><p>当一张表，把某个列设为主键的时候，则该列就是主键索引,下面的id 列就是主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> auto_increment ,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">defaul</span> ‘’);</span><br></pre></td></tr></table></figure><p>如果你创建表时，没有指定主键索引，也可以在创建表后，在添加, 指令:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> primary <span class="keyword">key</span> (列名);</span><br><span class="line">//举例</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> primary <span class="keyword">key</span> (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><h3 id="2-普通索引"><a href="#2-普通索引" class="headerlink" title="2.普通索引"></a>2.普通索引</h3><p>一般来说，普通索引的创建，是先创建表，然后在创建普通索引</p><p>比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表 (列<span class="number">1</span>,列名<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="3-创建全文索引"><a href="#3-创建全文索引" class="headerlink" title="3.创建全文索引"></a>3.创建全文索引</h3><p>全文索引，主要是针对对文件，文本的检索, 比如文章, 全文索引针对MyISAM有用。创建如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">       <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">       title <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">       <span class="keyword">body</span> <span class="built_in">TEXT</span>,</span><br><span class="line">       FULLTEXT (title,<span class="keyword">body</span>)</span><br><span class="line">     )<span class="keyword">engine</span>=myisam <span class="keyword">charset</span> utf8;</span><br></pre></td></tr></table></figure><p>如何使用全文索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> articles <span class="keyword">where</span> <span class="keyword">body</span> <span class="keyword">like</span> ‘%非科班%’;  //不会使用到全文索引</span><br><span class="line"></span><br><span class="line">// 查看是否使用索引:</span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> * <span class="keyword">from</span> articles <span class="keyword">where</span> <span class="keyword">body</span> <span class="keyword">like</span> ‘%非科班%’</span><br><span class="line"></span><br><span class="line">// 正确的用法是:</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> articles <span class="keyword">where</span> <span class="keyword">match</span>(title,<span class="keyword">body</span>) against(‘非科班’);</span><br></pre></td></tr></table></figure><p>说明:</p><ol><li><p>在mysql中fulltext 索引只针对 myisam生效</p></li><li><p>mysql自己提供的fulltext针对英文生效-&gt;sphinx (coreseek) 技术处理中文</p></li><li><p>使用方法是match(字段名..) against(‘关键字’)</p></li><li><p>全文索引一个 叫 停止词, 因为在一个文本中，创建索引是一个无穷大的数，因此，对一些常用词和字符，就不会创建，这些词，称为停止词.</p></li></ol><h3 id="4-唯一索引"><a href="#4-唯一索引" class="headerlink" title="4.唯一索引"></a>4.唯一索引</h3><p>当表的某列被指定为unique约束时，这列就是一个唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment , <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">unique</span>);</span><br></pre></td></tr></table></figure><p>这时, name 列就是一个唯一索引，unique字段可以为NULL,并可以有多NULL, 但是如果是具体内容，则不能重复，主键字段，不能为NULL,也不能重复。</p><p>创建唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> 索引名  <span class="keyword">on</span> 表名 (列表..);</span><br></pre></td></tr></table></figure><p>查询索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc 表名  //不能够显示索引名</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span>(es) <span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">keys</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">index</span> 索引名; </span><br><span class="line"></span><br><span class="line">//如果删除主键索引。</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> primary <span class="keyword">key</span></span><br></pre></td></tr></table></figure><h3 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h3><p>由于索引本身很大，占用磁盘空间，对dml操作有影响，变慢，满足以下条件的字段，才应该创建索引。</p><ol><li><p>肯定在where条经常使用</p></li><li><p>该字段的内容不是唯一的几个值</p></li><li><p>字段内容不是频繁变化</p></li></ol><p>explain 可以帮助我们在不真正执行某个sql语句时，就执行mysql怎样执行，这样利用我们去分析sql指令。</p><img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/explain.png" class="" title="explain"><ol><li><p>id：查询的序列号。</p></li><li><p>select_type：查询类型。</p></li><li><p>table：查询表名。</p></li><li><p>type：扫描方式，all表示全表扫描。</p></li><li><p>possible_keys：可是使用到的索引。</p></li><li><p>key：实际使用到的索引。</p></li><li><p>rows：该sql扫面了多少行。</p></li><li><p>Extra：sql语句额外的信息，比如排序方式</p></li></ol><h2 id="sql语句的小技巧"><a href="#sql语句的小技巧" class="headerlink" title="sql语句的小技巧"></a>sql语句的小技巧</h2><p>在使用group by 分组查询时，默认分组后，还会排序，可能会降低速度，在group by 后面增加 order by null 就可以防止排序。如下图所示:</p><img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/group_by.png" class="" title="group_by"><img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/group_by_null.png" class="" title="group_by_null"><p>有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept, emp <span class="keyword">where</span> dept.deptno=emp.deptno; </span><br><span class="line">// 替换成</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> dept.deptno=emp.deptno;</span><br></pre></td></tr></table></figure><h3 id="更多如何写出更好的sql，参考："><a href="#更多如何写出更好的sql，参考：" class="headerlink" title="更多如何写出更好的sql，参考："></a>更多如何写出更好的sql，参考：</h3><p><a href="https://www.jianshu.com/p/eccaebb6dc3c" target="_blank" rel="noopener">https://www.jianshu.com/p/eccaebb6dc3c</a></p><h2 id="正确的选择mysql的存储引擎"><a href="#正确的选择mysql的存储引擎" class="headerlink" title="正确的选择mysql的存储引擎"></a>正确的选择mysql的存储引擎</h2><p>Myisam : 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. ,比如 bbs 中的 发帖表，回复表。</p><p>INNODB : 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表。</p><img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/engine.png" class="" title="engine"><p>如果你的数据库的存储引擎是myisam,请一定记住要定时进行碎片整理</p><h2 id="分表技术"><a href="#分表技术" class="headerlink" title="分表技术"></a>分表技术</h2><p>为什么要分表？</p><p>（1） 如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I/O操作</p><p>（2）如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响这查询的性能。</p><p>（3）表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p><p>（4） 分表技术有(水平分割和垂直分割)</p><h3 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h3><p>垂直分割是指数据表列的拆分，把一张列比较多的表拆分为多张表。垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。</p><p>垂直分割比较常见：例如博客系统中的文章表，比如文章tbl_articles<br>(id, titile, summary, content, user_id, create_time)，因为文章中的内容content会比较长，放在tbl_articles中会严重影响表的查询速度，所以将内容放到tbl_articles_detail(article_id, content)，像文章列表只需要查询tbl_articles中的字段即可。</p><p>垂直拆分的优点：可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。</p><h3 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h3><p>水平拆分是指数据表行数据的拆分，表的行数超过500万行或者单表容量超过10GB时，查询就会变慢，这时可以把一张的表的数据拆成多张表来存放。水平分表尽可能使每张表的数据量相当，比较均匀。</p><p>水平拆分会给应用增加复杂度，它通常在查询是需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点。</p><p>因为只要索引关键字不大，则在索引用于查询时，表中增加2-3倍数据量，查询时也就增加读一个索引层的磁盘次数，所以水平拆分要考虑数据量的增长速度，根据实际情况决定是否需要对表进行水平拆分。</p><p>水平分割最重要的是找到分割的标准，不同的表应根据业务找出不同的标准</p><p>用户表可以根据用户的手机号段进行分割如user183、user150、user153、user189等，每个号段就是一张表</p><p>用户表也可以根据用户的id进行分割，加入分3张表user0,user1,user2，如果用户的id%3=0就查询user0表，<br>如果用户的id%3=1就查询user1表</p><p>对于订单表可以按照订单的时间进行分表</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>实现MySQL读写分离的前提是我们已经将MySQL主从复制配置完毕，读写分离实现方式：</p><p>（1）配置多数据源。</p><p>（2）使用mysql的proxy中间件代理工具。</p><h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><p>MySQL的主从复制和读写分离两者有着紧密的联系，首先要部署主从复制，只有主从复制完成了才能在此基础上进行数据的读写分离。</p><img src="/2020/07/04/MySQL%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0/master.png" class="" title="master_slave"><h3 id="读写分离的原理"><a href="#读写分离的原理" class="headerlink" title="读写分离的原理"></a>读写分离的原理</h3><p>读写分离就是只在主服务器上写，只在从服务器上读。基本原理是让主数据库处理事务性查询，而从服务器处理select查询。数据库复制被用来把事务性查询导致的变更同步到从数据库中。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/900e92d61861" target="_blank" rel="noopener">https://www.jianshu.com/p/900e92d61861</a></p><p><a href="https://www.jianshu.com/p/eccaebb6dc3c" target="_blank" rel="noopener">https://www.jianshu.com/p/eccaebb6dc3c</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Redis并用Redis实现定时任务</title>
      <link href="/2020/07/02/SpringBoot%E6%95%B4%E5%90%88Redis%E5%B9%B6%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2020/07/02/SpringBoot%E6%95%B4%E5%90%88Redis%E5%B9%B6%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis是一种可基于内存也可基于持久话的日志型、key-value数据库。因为性能高，存储数据类型丰富等优势常被用作数据缓存。</p><p>下面介绍Redis集成到SpringBoot2.2.4和Redis定时任务的实现。</p><a id="more"></a><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>前提要在本地安装好redis或者是使用云redis，这里就不说了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--      redis                      --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;!-- 1.5的版本默认采用的连接池技术是jedis  2.0以上版本默认连接池是lettuce, 在这里采用jedis，所以需要排除lettuce的jar --&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;io.lettuce&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;lettuce-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- 添加jedis客户端 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--spring2.0集成redis所需common-pool2--&gt;</span><br><span class="line">        &lt;!-- 必须加上，jedis依赖此  --&gt;</span><br><span class="line">        &lt;!-- spring boot 2.0 的操作手册有标注 大家可以去看看 地址是：https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-boot&#x2F;docs&#x2F;2.0.3.RELEASE&#x2F;reference&#x2F;htmlsingle&#x2F;--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.5.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="在yml中配置redis"><a href="#在yml中配置redis" class="headerlink" title="在yml中配置redis"></a>在yml中配置redis</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">#数据库索引，默认为0</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#服务器地址，默认localhost</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment">#端口，默认6379</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#密码，默认为空</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">#连接池最大连接数，默认为8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment">#连接池最大阻塞等待时间，使用负值表示没有限制</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#连接池最大空闲连接，默认为8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment">#连接池中的最小空闲连接，默认为0</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#连接超时时间(毫秒)    </span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="创建redis的Service类或者是Util类"><a href="#创建redis的Service类或者是Util类" class="headerlink" title="创建redis的Service类或者是Util类"></a>创建redis的Service类或者是Util类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入redis缓存（不设置expire存活时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"写入redis缓存失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入redis缓存（设置expire存活时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, String value, Long expire)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            redisTemplate.expire(key, expire, TimeUnit.SECONDS);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"写入redis缓存（设置expire存活时间）失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取redis缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations operations = redisTemplate.opsForValue();</span><br><span class="line">            result = operations.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"读取redis缓存失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断redis缓存中是否有对应的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"判断redis缓存中是否有对应的key失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis根据key删除对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(exists(key))&#123;</span><br><span class="line">                redisTemplate.delete(key);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"redis根据key删除对应的value失败！错误信息为："</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis根据keys批量删除对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String... keys)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是SpringBoot集成Redis的步骤了，下面说一下Redis完成定时任务。</p><h2 id="使用定时任务的场景"><a href="#使用定时任务的场景" class="headerlink" title="使用定时任务的场景"></a>使用定时任务的场景</h2><p>使用Java做过项目的人大概都用过定时器。一般来说，项目里订单模块和评论模块，都会涉及到定时任务执行。比如说：</p><p>用户下订单后，需要在5分钟内完成支付，否则订单关闭；</p><p>用户在完成订单后，如果没有评论，过一星期，系统自动评论，并完结。</p><h2 id="使用Redis解决"><a href="#使用Redis解决" class="headerlink" title="使用Redis解决"></a>使用Redis解决</h2><p>Redis中有一个expire命令，用来设置key的过期时间。使用发布订阅，可以接收到key的过期提醒，当key过期时，再执行取消订单的逻辑，就可以了。</p><h2 id="Redis过期通知"><a href="#Redis过期通知" class="headerlink" title="Redis过期通知"></a>Redis过期通知</h2><p>要使用Redis的过期通知功能，需要首先开启该功能。</p><p>在配置文件中加入如下语句：</p><p>notify-keyspace-events Ex</p><h2 id="在SpringBoot中编写代码"><a href="#在SpringBoot中编写代码" class="headerlink" title="在SpringBoot中编写代码"></a>在SpringBoot中编写代码</h2><p>首先写接收通知的处理方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisMessageReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收redis消息，并处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 过期的redis key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通知的key是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写频道订阅的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis 订阅频道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listenerAdapter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory connectionFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            MessageListenerAdapter listenerAdapter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 订阅通道，key过期时通知</span></span><br><span class="line">        container.addMessageListener(listenerAdapter, <span class="keyword">new</span> PatternTopic(<span class="string">"__keyevent@0__:expired"</span>));</span><br><span class="line">        <span class="comment">// 可以订阅多个通道</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置redis事件监听处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receiver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MessageListenerAdapter <span class="title">listenerAdapter</span><span class="params">(RedisMessageReceiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageListenerAdapter(receiver, <span class="string">"receiveMessage"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了</p><h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><p>运行程序之后随意设置一个key，并设置过期时间：</p><img src="/2020/07/02/SpringBoot%E6%95%B4%E5%90%88Redis%E5%B9%B6%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/key.png" class="" title="key"><p>过了过期时间十秒后会收到控制台输出：</p><img src="/2020/07/02/SpringBoot%E6%95%B4%E5%90%88Redis%E5%B9%B6%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/out.png" class="" title="out"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000020906185" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020906185</a></p><p><a href="https://www.zhangjava.com/%E4%BD%BF%E7%94%A8Redis%E5%AE%8C%E6%88%90%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" target="_blank" rel="noopener">https://www.zhangjava.com/%E4%BD%BF%E7%94%A8Redis%E5%AE%8C%E6%88%90%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java使用iTextPDF生成PDF文件</title>
      <link href="/2020/07/01/Java%E4%BD%BF%E7%94%A8iTextPDF%E7%94%9F%E6%88%90PDF%E6%96%87%E4%BB%B6/"/>
      <url>/2020/07/01/Java%E4%BD%BF%E7%94%A8iTextPDF%E7%94%9F%E6%88%90PDF%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="iText介绍和说明"><a href="#iText介绍和说明" class="headerlink" title="iText介绍和说明"></a>iText介绍和说明</h2><p>因为项目需要生成PDF文件，所以去找了一下能够生成PDF的Java工具，看到了iText可以说好评如潮。</p><p>如果你想通过java操作PDF文件，那么 iText 绝对是你的首选。</p><a id="more"></a><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>这里使用的是iText5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.itextpdf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;itextpdf&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.10&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.itextpdf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;itext-asian&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用步骤简单介绍"><a href="#使用步骤简单介绍" class="headerlink" title="使用步骤简单介绍"></a>使用步骤简单介绍</h2><p>快速入手iText拢共需要5步：</p><ol><li><p>创建文档实例 Document</p></li><li><p>获取PdfWriter实例 （需要指定Document实例 和pdf 生成的磁盘路径）</p></li><li><p>打开文档</p></li><li><p>添加段落内容</p></li><li><p>关闭操作文档实例 （操作完成后必须执行文档关闭操作）</p></li></ol><h2 id="创建工具类"><a href="#创建工具类" class="headerlink" title="创建工具类"></a>创建工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标准字体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Font NORMALFONT;</span><br><span class="line">    <span class="comment">// 加粗字体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Font BOLDFONT;</span><br><span class="line">    <span class="comment">//固定高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> fixedHeight = <span class="number">27f</span>;</span><br><span class="line">    <span class="comment">//间距</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> spacing = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BaseFont bfChinese = BaseFont.createFont(<span class="string">"STSong-Light"</span>, <span class="string">"UniGB-UCS2-H"</span>, BaseFont.NOT_EMBEDDED);</span><br><span class="line">            NORMALFONT = <span class="keyword">new</span> Font(bfChinese, <span class="number">10</span>, Font.NORMAL);</span><br><span class="line">            BOLDFONT = <span class="keyword">new</span> Font(bfChinese, <span class="number">14</span>, Font.BOLD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">createDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成pdf</span></span><br><span class="line">        Document document = <span class="keyword">new</span> Document();</span><br><span class="line">        <span class="comment">// 页面大小</span></span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Rectangle(PageSize.A4);</span><br><span class="line">        <span class="comment">// 页面背景颜色</span></span><br><span class="line">        rectangle.setBackgroundColor(BaseColor.WHITE);</span><br><span class="line">        document.setPageSize(rectangle);</span><br><span class="line">        <span class="comment">// 页边距 左，右，上，下</span></span><br><span class="line">        document.setMargins(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> document;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 段落内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Paragraph <span class="title">createParagraph</span><span class="params">(String text, Font font)</span> </span>&#123;</span><br><span class="line">        Paragraph elements = <span class="keyword">new</span> Paragraph(text, font);</span><br><span class="line">        elements.setSpacingBefore(<span class="number">5</span>);</span><br><span class="line">        elements.setSpacingAfter(<span class="number">5</span>);</span><br><span class="line">        elements.setSpacingAfter(spacing);</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Font <span class="title">createFont</span><span class="params">(<span class="keyword">int</span> fontNumber, <span class="keyword">int</span> fontSize, BaseColor fontColor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中文字体 ----不然中文会乱码</span></span><br><span class="line">        BaseFont bf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bf = BaseFont.createFont(<span class="string">"STSong-Light"</span>, <span class="string">"UniGB-UCS2-H"</span>, BaseFont.NOT_EMBEDDED);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Font(bf, fontNumber, fontSize, fontColor);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Font(bf, Font.DEFAULTSIZE, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏表格边框线</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell 单元格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">disableBorderSide</span><span class="params">(PdfPCell cell)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cell.disableBorderSide(<span class="number">1</span>);</span><br><span class="line">            cell.disableBorderSide(<span class="number">2</span>);</span><br><span class="line">            cell.disableBorderSide(<span class="number">4</span>);</span><br><span class="line">            cell.disableBorderSide(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建居中得单元格</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PdfPCell <span class="title">createCenterPdfPCell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PdfPCell cell = <span class="keyword">new</span> PdfPCell();</span><br><span class="line">        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);</span><br><span class="line">        cell.setHorizontalAlignment(Element.ALIGN_CENTER);</span><br><span class="line">        cell.setFixedHeight(fixedHeight);</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定文字得单元格</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PdfPCell <span class="title">createCenterPdfPCell</span><span class="params">(String text, <span class="keyword">int</span> rowSpan, <span class="keyword">int</span> colSpan, Font font)</span> </span>&#123;</span><br><span class="line">        PdfPCell cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(text, font));</span><br><span class="line">        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);</span><br><span class="line">        cell.setHorizontalAlignment(Element.ALIGN_LEFT);</span><br><span class="line">        cell.setFixedHeight(fixedHeight);</span><br><span class="line">        cell.setRowspan(rowSpan);</span><br><span class="line">        cell.setColspan(colSpan);</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len 表格列数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PdfPTable <span class="title">createPdfPTable</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        PdfPTable pdfPTable = <span class="keyword">new</span> PdfPTable(len);</span><br><span class="line">        pdfPTable.setSpacingBefore(<span class="number">5</span>);</span><br><span class="line">        pdfPTable.setHorizontalAlignment(Element.ALIGN_CENTER);</span><br><span class="line">        <span class="keyword">return</span> pdfPTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建controller进行测试"><a href="#创建controller进行测试" class="headerlink" title="创建controller进行测试"></a>创建controller进行测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/28 3:17 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/pdf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/generate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">generatePDF</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String filename = <span class="string">"测试pdf"</span>;</span><br><span class="line">        <span class="comment">// 设置下载格式为pdf</span></span><br><span class="line">        response.setContentType(<span class="string">"application/x-download"</span>);</span><br><span class="line">        response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + URLEncoder.encode(filename, <span class="string">"UTF-8"</span>) + <span class="string">".pdf"</span>);</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> BufferedOutputStream(response.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Document document = new Document();</span></span><br><span class="line">        Document document = PdfUtil.createDocument();</span><br><span class="line">        <span class="comment">// 2. 获取writer</span></span><br><span class="line">        PdfWriter.getInstance(document, os);</span><br><span class="line">        <span class="comment">// 3. open()</span></span><br><span class="line">        document.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置字体</span></span><br><span class="line">        Font blackFont = PdfUtil.createFont(<span class="number">10</span>, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line">        Font blueFont = PdfUtil.createFont(<span class="number">10</span>, Font.NORMAL, BaseColor.BLUE);</span><br><span class="line">        Font bigFont = PdfUtil.createFont(<span class="number">14</span>, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line">        Font littleFont = PdfUtil.createFont(<span class="number">10</span>, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line"></span><br><span class="line">        Paragraph title = PdfUtil.createParagraph(<span class="string">"测试pdf"</span>, bigFont);</span><br><span class="line">        title.setAlignment(Element.ALIGN_CENTER);</span><br><span class="line">        <span class="comment">// 4. 添加段落内容</span></span><br><span class="line">        document.add(title);</span><br><span class="line">        <span class="comment">// 5. close()</span></span><br><span class="line">        document.close();</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response().setContent(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>下载页面：</p><img src="/2020/07/01/Java%E4%BD%BF%E7%94%A8iTextPDF%E7%94%9F%E6%88%90PDF%E6%96%87%E4%BB%B6/download_interface.png" class="" title="download_interface"><p>下载的文件效果：</p><img src="/2020/07/01/Java%E4%BD%BF%E7%94%A8iTextPDF%E7%94%9F%E6%88%90PDF%E6%96%87%E4%BB%B6/download_file.png" class="" title="download_file">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring定时任务-Scheduled注解使用方式</title>
      <link href="/2020/06/30/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-Scheduled%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/06/30/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-Scheduled%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用@Scheduled cron表达式标注任务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(testTask<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="cron表达式的语法"><a href="#cron表达式的语法" class="headerlink" title="cron表达式的语法"></a>cron表达式的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> 按顺序依次为</span><br><span class="line">1  秒（0~59）</span><br><span class="line">2  分钟（0~59）</span><br><span class="line">3 小时（0~23）</span><br><span class="line">4  天（0~31）</span><br><span class="line">5 月（0~11）</span><br><span class="line">6  星期（1~7 1&#x3D;SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）</span><br><span class="line">7.年份（1970－2099）</span><br><span class="line">其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18&#x2F;4)(&#x2F;表示每隔4小时),一个列表(1,3,5),通配符。由于&quot;月份中的日期&quot;和&quot;星期中的日期&quot;这两个元素互斥的,必须要对其中一个设置?.</span><br><span class="line"> 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点</span><br><span class="line"> 0 0&#x2F;30 9-17 * * ?   朝九晚五工作时间内每半小时</span><br><span class="line"> 0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line"> &quot;0 0 12 * * ?&quot; 每天中午12点触发 </span><br><span class="line"> &quot;0 15 10 ? * *&quot; 每天上午10:15触发 </span><br><span class="line"> &quot;0 15 10 * * ?&quot; 每天上午10:15触发 </span><br><span class="line"> &quot;0 15 10 * * ? *&quot; 每天上午10:15触发 </span><br><span class="line"> &quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发 </span><br><span class="line"> &quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发 </span><br><span class="line"> &quot;0 0&#x2F;5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发 </span><br><span class="line"> &quot;0 0&#x2F;5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </span><br><span class="line"> &quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发 </span><br><span class="line"> &quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发 </span><br><span class="line"> &quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发 </span><br><span class="line"> &quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发 </span><br><span class="line"> &quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发 </span><br><span class="line"> &quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发 </span><br><span class="line"> &quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发 </span><br><span class="line"> &quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发 </span><br><span class="line"> 有些子表达式能包含一些范围或列表</span><br><span class="line"> 例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”</span><br><span class="line"> “*”字符代表所有可能的值</span><br><span class="line"> “&#x2F;”字符用来指定数值的增量</span><br><span class="line"> 例如：在子表达式（分钟）里的“0&#x2F;15”表示从第0分钟开始，每15分钟</span><br><span class="line">          在子表达式（分钟）里的“3&#x2F;20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样</span><br><span class="line"> “？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值</span><br><span class="line"> 当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</span><br><span class="line"> “L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写</span><br><span class="line"> 如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”表示这个月的倒数第６天</span><br><span class="line"> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</span><br><span class="line"> W 字符代表着平日(Mon-Fri)，并且仅能用于日域中。它用来指定离指定日的最近的一个平日。大部分的商业处理都是基于工作周的，所以 W 字符可能是非常重要的。</span><br><span class="line"> 例如，日域中的 15W 意味着 &quot;离该月15号的最近一个平日。&quot; 假如15号是星期六，那么 trigger 会在14号(星期五)触发，因为星期四比星期一离15号更近。</span><br><span class="line"> C：代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。</span><br><span class="line"> 字段   允许值   允许的特殊字符</span><br><span class="line"> 秒           0-59           , - * &#x2F;</span><br><span class="line"> 分           0-59           , - * &#x2F;</span><br><span class="line"> 小时           0-23           , - * &#x2F;</span><br><span class="line"> 日期           1-31           , - * ? &#x2F; L W C</span><br><span class="line"> 月份           1-12 或者 JAN-DEC           , - * &#x2F;</span><br><span class="line"> 星期           1-7 或者 SUN-SAT           , - * ? &#x2F; L C #</span><br><span class="line"> 年（可选）           留空, 1970-2099           , - * &#x2F;</span><br></pre></td></tr></table></figure><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>如果我的任务在5秒内没有执行完呢？spring会怎么处理呢？</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"*/5 * * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">6</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-06-11 16:02:50.035 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:02:56.496 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:03:00.006 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:03:06.013 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:03:10.115 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:03:17.267 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:03:20.055 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:03:26.164 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure><p>我们可以发现，spring他的处理方式是等待上一个任务执行完成后，再去执行下一个任务，也就是说spring的定时任务<strong>默认是单线程</strong>的，而不会开启另一条线程去执行任务。</p><p>眼尖的小伙伴应该发现任务执行的时间还是怪怪的，任务开始到结束的时间间隔确实是6s，但是下一个任务的开始时间和上一个任务的结束时间之间为什么差了4s呢？这个时间是怎么设定的呢？</p><p>这个问题和spring处理cron表达式这种定时任务的机制有关，我们稍后再说，先讲讲@Scheduled注解的另外两个属性：<strong>fixedRate和fixedDelay</strong></p><h2 id="fixedDelay"><a href="#fixedDelay" class="headerlink" title="fixedDelay"></a>fixedDelay</h2><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5</span>*<span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">6</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-06-11 16:30:56.246 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:31:03.114 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:31:08.122 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:31:14.139 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:31:19.149 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:31:25.261 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:31:30.269 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:31:36.385 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure><p>我们可以发现，这个结果和上一个使用cro表达式的结果好像啊。但是仔细看我们就会发现，这次所有的时间都是我们配置的：任务开始到结束间隔6s，上一个任务结束时间到下一个任务开始时间是5秒，这样看来是比较符合我们的设置的。</p><p>fixedDelay是设定上一个任务结束后多久执行下一个任务，也就是<strong>fixedDelay只关心上一任务的结束时间和下一任务的开始时间</strong>。</p><h2 id="fixedRate"><a href="#fixedRate" class="headerlink" title="fixedRate"></a>fixedRate</h2><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5</span>*<span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">6</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-06-11 16:54:29.613 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:54:36.113 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:54:36.118 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:54:42.580 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:54:42.607 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:54:48.632 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 16:54:48.639 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 16:54:55.188 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure><p>这次我们可以看到，上一个任务结束后，下一个任务立刻开始执行了，结合第一次测试，我们就可以推断，<strong>fixedRate设置的上一个任务的开始时间到下一个任务开始时间的间隔</strong>，那我们的推断对不对呢？这次我们把任务执行时间改成2s，测试走起~</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5</span>*<span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-06-11 17:08:37.500 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:08:39.510 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:08:43.086 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:08:45.093 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:08:48.025 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:08:50.083 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:08:53.239 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:08:55.245 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure><p>结果和我们推断的一致，两个任务的开始时间间隔是5s，当到达任务的开始执行时间，但上一个任务却没有完成时，spring会等待上一个任务执行完，并立即开始执行本次任务。</p><h2 id="Cron执行机制"><a href="#Cron执行机制" class="headerlink" title="Cron执行机制"></a>Cron执行机制</h2><p>上面介绍了cron表达式、fixedRate和fixedDelay三种方式，但还有一个遗留问题，那就是cron的执行机制，为什么使用它时两个任务间隔并不固定呢？其实spring在处理使用cron表达式这种定时任务时，其实依旧关注的是任务的开始时间，但是他和fixedDelay不同的是，<strong>他会在配置任务开始时判断任务是否可以执行，如果可以则执行，如果不可以，那么他将不执行此次任务，等待下一次执行</strong>。比如下图</p><img src="/2020/06/30/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-Scheduled%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/cron.png" class="" title="cron"><p>AB两个任务配置的执行规则都是每隔5s执行，A任务执行时间是4s，而B任务执行时间是7s。</p><p>A任务可以在执行内执行完任务，所以每隔5s他就会正常执行，0s开始，4s时结束，那么在5s的时候他会再次执行，如此反复。</p><p>而B任务的执行时间是7s，执行时间超过了任务的间隔时间，就如图中例子，B任务在10s开始，执行时间持续了7s，当15s的时候本来应该是开始执行第二次，但由于第一次任务还未执行完成，所以第二次任务将不会执行，而是到20s要开始执行第三次任务的时候，再次判断，发现上一次B任务已经执行完毕，这时才开始再次执行B任务。</p><p>还记得我们刚开始使用cron表达式做了一个执行时间为6s，间隔5s执行的测试任务吗？这次我们改一改，将执行时间改为8s，再次测试。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task run"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">8</span>*<span class="number">1000</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName()+<span class="string">"===task end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-06-11 17:54:30.014 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:54:38.033 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:54:40.488 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:54:49.617 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:54:50.260 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:54:58.270 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br><span class="line">2018-06-11 17:55:00.845 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task run</span><br><span class="line">2018-06-11 17:55:08.856 [pool-12-thread-1] INFO  service.task.testTask -pool-12-thread-1&#x3D;&#x3D;&#x3D;task end</span><br></pre></td></tr></table></figure><p>对比执行时间为6s的测试结果，可以发现两次任务开始的时间都是在下下一个5s的时候，也就是证实了之前等待的结论。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、fixedRate配置了上一次任务的开始时间到下一次任务的开始时间的间隔，每次任务都会执行；</p><p>2、fixedDelay配置了上一次任务的结束时间到下一次任务的开始时间的间隔，每次任务都会执行；</p><p>3、cron表达式配置了在哪一刻执行任务，会在配置的任务开始时间判断任务是否可以执行，如果能则执行，不能则会跳过本次执行；</p><p>4、<strong>如果是强调任务间隔的定时任务，建议使用fixedRate和fixedDelay，如果是强调任务在某时某分某刻执行的定时任务，建议使用cron表达式。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000015253688" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015253688</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ-IDEA-高级调试技巧</title>
      <link href="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="一、条件断点"><a href="#一、条件断点" class="headerlink" title="一、条件断点"></a>一、条件断点</h2><p>循环中经常用到这个技巧，比如：遍历1个大List的过程中，想让断点停在某个特定值。</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/condition.png" class="" title="condition"><p>参考上图，在断点的位置，右击断点旁边的小红点，会出来一个界面，在Condition这里填入断点条件即可，这样调试时，就会自动停在i=10的位置</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/condition_result.png" class="" title="condition_result"><a id="more"></a><h2 id="二、回到”上一步”"><a href="#二、回到”上一步”" class="headerlink" title="二、回到”上一步”"></a>二、回到”上一步”</h2><p>该技巧最适合特别复杂的方法套方法的场景，好不容易跑起来，一不小心手一抖，断点过去了，想回过头看看刚才的变量值，如果不知道该技巧，只能再跑一遍。</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/back.png" class="" title="back"><p>参考上图，method1方法调用method2，当前断点的位置j=100，点击上图红色箭头位置的Drop Frame图标后，时间穿越了</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/back_result.png" class="" title="back_result"><p>回到了method1刚开始调用的时候，变量i变成了99，没毛病吧，老铁们，是不是很6 :)</p><p>注：好奇心是人类进步的阶梯，如果想知道为啥这个功能叫Drop Frame，而不是类似Back To Previous 之类的，可以去翻翻JVM的书，JVM内部以栈帧为单位保存线程的运行状态，drop frame即扔掉当前运行的栈帧，这样当前“指针”的位置，就自然到了上一帧的位置。</p><h2 id="三、多线程调试"><a href="#三、多线程调试" class="headerlink" title="三、多线程调试"></a>三、多线程调试</h2><p>多线程同时运行时，谁先执行，谁后执行，完全是看CPU心情的，无法控制先后，运行时可能没什么问题，但是调试时就比较麻烦了，最明显的就是断点乱跳，一会儿停这个线程，一会儿停在另一个线程，比如下图：</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/thread.png" class="" title="thread"><p>如果想希望下一个断点位置是第2句诗句，可能要失望了：</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/thread2.png" class="" title="thread2"><p>如果想让线程在调试时，想按自己的愿意来，让它停在哪个线程就停在哪个线程，可以在图中3个断点的小红点上右击，</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/suspend.png" class="" title="suspend"><p>即：Suspend挂起的条件是按每个线程来，而非All。把这3个断点都这么设置后，再来一发试试</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/sus_result.png" class="" title="sus_result"><p>注意上图中的红框位置，断点停下来时，这个下拉框可以看到各个线程（注：给线程起个容易识别的名字是个好习惯！），我们可以选择线程“天空中的飞鸟”</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/choose.png" class="" title="choose"><p>断点如愿停在了第2句诗。</p><h2 id="四、远程调试"><a href="#四、远程调试" class="headerlink" title="四、远程调试"></a>四、远程调试</h2><p>这也是一个装B的利器，本机不用启动项目，只要有源代码，可以在本机直接远程调试服务器上的代码，打开姿势如下：</p><h3 id="4-1-项目启动时，先允许远程调试"><a href="#4-1-项目启动时，先允许远程调试" class="headerlink" title="4.1 项目启动时，先允许远程调试"></a>4.1 项目启动时，先允许远程调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xms512m -Xmx512m -Xdebug -Xnoagent -Djava.compiler&#x3D;NONE -Xrunjdwp:transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;9081 -Djava.ext.dirs&#x3D;. $&#123;main_class&#125;</span><br></pre></td></tr></table></figure><p>起作用的就是</p><p>-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9081</p><p>注意：远程调试从技术上讲，就是在本机与远程建立scoket通讯，所以端口不要冲突，而且本机要允许访问远程端口，另外这一段参数，放要在-jar 或 ${main_class}的前面</p><h3 id="4-2-idea中设置远程调试"><a href="#4-2-idea中设置远程调试" class="headerlink" title="4.2 idea中设置远程调试"></a>4.2 idea中设置远程调试</h3><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/remote.png" class="" title="remote"><p>然后就可以调试了</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/remote_test.png" class="" title="remote_test"><p>前提是本机有项目的源代码 ，在需要的地方打个断点，然后访问一个远程的url试试，断点就会停下来。</p><h2 id="五、临时执行表达式-修改变量的运行值"><a href="#五、临时执行表达式-修改变量的运行值" class="headerlink" title="五、临时执行表达式/修改变量的运行值"></a>五、临时执行表达式/修改变量的运行值</h2><p>调试时，可以临时执行一些表达式，参考下图：点击这二个图标中的任何1个都可以</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/change.png" class="" title="change"><p>点击+号后，就可以在新出现的输入框里输入表达式，比如i+5</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/input.png" class="" title="input"><p>然后回车，马上就能看到结果 </p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/return.png" class="" title="return"><p>当然，如果调试时，想动态修改变量的值，也很容易，在变量上右击，然后选择Set Value，剩下的事，地球人都知道。</p><img src="/2020/06/24/IntelliJ-IDEA-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/set_value.png" class="" title="set_value"><p>善用上述调试技巧，相当大家撸起代码来会更有感觉，祝大家端午节愉快！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/jun1019/p/9741224.html" target="_blank" rel="noopener">https://www.cnblogs.com/jun1019/p/9741224.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何记忆Spring-Bean的生命周期</title>
      <link href="/2020/06/23/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/06/23/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>“请你描述下 Spring Bean 的生命周期？”，这是面试官考察 Spring 的常用问题，可见是 Spring 中很重要的知识点。</p><img src="/2020/06/23/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/total_process.png" class="" title="总体流程图"><p>其实要记忆该过程，还是需要我们先去理解，本文将从以下两方面去帮助理解 Bean 的生命周期：</p><ul><li><p>生命周期的概要流程：对 Bean 的生命周期进行概括，并且结合代码来理解；</p></li><li><p>扩展点的作用：详细介绍 Bean 生命周期中所涉及到的扩展点的作用。</p></li></ul><a id="more"></a><h2 id="2-生命周期的概要流程"><a href="#2-生命周期的概要流程" class="headerlink" title="2. 生命周期的概要流程"></a>2. 生命周期的概要流程</h2><p>Bean 的生命周期概括起来就是 <strong>4</strong> 个阶段：</p><p><strong>实例化</strong>（Instantiation）</p><p><strong>属性赋值</strong>（Populate）</p><p><strong>初始化</strong>（Initialization）</p><p><strong>销毁</strong>（Destruction）</p><img src="/2020/06/23/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/classify.png" class="" title="划分阶段的总体图"><ol><li>实例化：第 1 步，实例化一个 bean 对象；</li></ol><ol start="2"><li>属性赋值：第 2 步，为 bean 设置相关属性和依赖；</li></ol><ol start="3"><li>初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；</li></ol><ol start="4"><li>销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。</li></ol><p>下面我们结合代码来直观的看下，在 doCreateBean() 方法中能看到依次执行了这 4 个阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 实例化</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 属性赋值</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 3. 初始化</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 销毁-注册回调接口</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于初始化包含了第 3~7步，较复杂，所以我们进到 initializeBean() 方法里具体看下其过程（注释的序号对应图中序号）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3. 检查 Aware 相关接口并设置相关依赖</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. BeanPostProcessor 前置处理</span></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">    <span class="comment">// 6. 若配置自定义的 init-method方法，则执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. BeanPostProceesor 后置处理</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 invokInitMethods() 方法中会检查 InitializingBean 接口和 init-method 方法，销毁的过程也与其类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisposableBeanAdapter.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 9. 若实现 DisposableBean 接口，则执行 destory()方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, <span class="keyword">this</span>.acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 10. 若配置自定义的 detory-method 方法，则执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToInvoke = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (methodToInvoke != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 Spring 的源码我们可以直观的看到其执行过程，而我们记忆其过程便可以从这 4 个阶段出发，实例化、属性赋值、初始化、销毁。其中细节较多的便是初始化，涉及了 Aware、BeanPostProcessor、InitializingBean、init-method 的概念。这些都是 Spring 提供的扩展点，其具体作用将在下一节讲述。</p><h2 id="3-扩展点的作用"><a href="#3-扩展点的作用" class="headerlink" title="3. 扩展点的作用"></a>3. 扩展点的作用</h2><h3 id="3-1-Aware-接口"><a href="#3-1-Aware-接口" class="headerlink" title="3.1 Aware 接口"></a>3.1 Aware 接口</h3><p>若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以<strong>通过让 bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源</strong>。 </p><p>Spring 中提供的 Aware 接口有：</p><ol><li><p>BeanNameAware：注入当前 bean 对应 beanName；</p></li><li><p>BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader；</p></li><li><p>BeanFactoryAware：注入 当前BeanFactory容器 的引用。</p></li></ol><p>其代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是针对 BeanFactory 类型的容器，而对于 ApplicationContext 类型的容器，也提供了 Aware 接口，只不过这些 Aware 接口的注入实现，是通过 BeanPostProcessor 的方式注入的，但其作用仍是注入依赖。</p><ol><li><p>EnvironmentAware：注入 Enviroment，一般用于获取配置属性；</p></li><li><p>EmbeddedValueResolverAware：注入 EmbeddedValueResolver（Spring EL解析器），一般用于参数解析；</p></li><li><p>ApplicationContextAware（ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware）：注入 ApplicationContext 容器本身。</p></li></ol><p>其代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationContextAwareProcessor.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">        ((EnvironmentAware)bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">        ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">        ((ResourceLoaderAware)bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">        ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">        ((MessageSourceAware)bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">        ((ApplicationContextAware)bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-BeanPostProcessor"><a href="#3-2-BeanPostProcessor" class="headerlink" title="3.2 BeanPostProcessor"></a>3.2 BeanPostProcessor</h3><p>BeanPostProcessor 是 Spring 为修改 bean提供的强大扩展点，其可作用于容器中所有 bean，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化前置处理</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化后置处理</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用场景有：</p><ol><li><p>对于标记接口的实现类，进行自定义处理。例如3.1节中所说的ApplicationContextAwareProcessor，为其注入相应依赖；再举个例子，自定义对实现解密接口的类，将对其属性进行解密处理；</p></li><li><p>为当前对象提供代理实现。例如 Spring AOP 功能，生成对象的代理类，然后返回。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="comment">// 返回代理类</span></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-InitializingBean-和-init-method"><a href="#3-3-InitializingBean-和-init-method" class="headerlink" title="3.3 InitializingBean 和 init-method"></a>3.3 InitializingBean 和 init-method</h3><p>InitializingBean 和 init-method 是 Spring 为 <strong>bean 初始化</strong>提供的扩展点。</p><p>InitializingBean接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 afterPropertiesSet() 方法写初始化逻辑。</p><p>指定 init-method 方法，指定初始化方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"com.chaycao.Demo"</span> <span class="attr">init-method</span>=<span class="string">"init()"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DisposableBean 和 destory-method 与上述类似，就不描述了。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>最后总结下如何记忆 Spring Bean 的生命周期：</p><ul><li><p>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</p></li><li><p>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作；</p></li><li><p>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</p></li></ul><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><p><a href="https://juejin.im/post/5e4791a7f265da5715630629" target="_blank" rel="noopener">https://juejin.im/post/5e4791a7f265da5715630629</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java使用easyexcel操作excel</title>
      <link href="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/"/>
      <url>/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在工作中，使用excel表格处理数据是很常见的操作，本文就来讲解下如何使用开源轮子实现下载、导入、导出的功能。</p><p>在之前，很多Java程序员都喜欢使用POI的类库来操作excel,但是非常的不方便，不仅代码写的很臃肿，还要处理各种office版本兼容问题，最怕的就是使用不当很容易造成内存溢出，因此今天给大家推荐阿里的一款开源项目 <strong>easyexcel</strong>。</p><a id="more"></a><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>easyexcel是一款快速、简单避免OOM的java处理Excel工具</p><p>github地址:<a href="https://github.com/alibaba/easyexcel" target="_blank" rel="noopener">https://github.com/alibaba/easyexcel</a></p><p>Star:15.2k</p><p>看了下，两天前项目团队还有在完善代码，可见项目还是挺活跃的</p><h3 id="项目集成"><a href="#项目集成" class="headerlink" title="项目集成"></a>项目集成</h3><p>使用idea开发工具简单创建了一个easyexcel-demo项目，加入了web模块以及easyexcel maven依赖，依赖如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;easyexcel --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easyexcel&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>好了，我们就开始写功能了。</p><h3 id="1、实现已有Excel模板下载"><a href="#1、实现已有Excel模板下载" class="headerlink" title="1、实现已有Excel模板下载"></a>1、实现已有Excel模板下载</h3><p>很多系统有数据批量导入的场景，因为在页面上批量加数据时间成本太大了，但是一般导入的时候得按照一定的格式改，所以一般好的产品会先让用户下载一个带有格式的文档，然后按照格式写好以后上传导入，我们来实现这个功能吧！</p><h4 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h4><p>首先我们创建一个模板文件，内容如图:</p><img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/excel_format.png" class="" title="excel表格样式"><h4 id="将模板文件放置在项目里"><a href="#将模板文件放置在项目里" class="headerlink" title="将模板文件放置在项目里"></a>将模板文件放置在项目里</h4><p>然后我们把它放在项目的配置文件下，如图：</p><img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/excel_in_project.png" class="" title="excel在项目中的位置"><p>然后下载代码也很简单，主要分为<strong>加载资源-&gt;读取资源-&gt;写入响应流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/downloadTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadTemplate</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathResource classPathResource = <span class="keyword">new</span> ClassPathResource(<span class="string">"excelTemplate/easyexcel.xls"</span>);</span><br><span class="line">        InputStream inputStream = classPathResource.getInputStream();</span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(inputStream);</span><br><span class="line">        response.setContentType(<span class="string">"application/vnd.ms-excel"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"content-Disposition"</span>, <span class="string">"attachment;filename="</span> + URLEncoder.encode(<span class="string">"easyexcel.xls"</span>, <span class="string">"utf-8"</span>));</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Expose-Headers"</span>, <span class="string">"content-Disposition"</span>);</span><br><span class="line">        OutputStream outputStream = response.getOutputStream();</span><br><span class="line">        workbook.write(outputStream);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>输入网址 <a href="http://localhost:8080/excel/downloadTemplate" target="_blank" rel="noopener">http://localhost:8080/excel/downloadTemplate</a> 进行测试：</p><img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/download_template.png" class="" title="测试下载模版"><h3 id="2-写入数据并生成文件"><a href="#2-写入数据并生成文件" class="headerlink" title="2.写入数据并生成文件"></a>2.写入数据并生成文件</h3><p>将数据导出到文档这种场景可以说是最常见的了，那么怎么使用easyExcel快速实现呢，我们同样还是以上面的模板为例</p><h4 id="定义模型映射对象-UserExcelModel"><a href="#定义模型映射对象-UserExcelModel" class="headerlink" title="定义模型映射对象 UserExcelModel"></a>定义模型映射对象 UserExcelModel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserExcelModel</span>  <span class="keyword">extends</span> <span class="title">BaseRowModel</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"用户名"</span>, index = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"年龄"</span>, index = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"手机号"</span>, index = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"性别"</span>, index = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserExcelModel</span><span class="params">(String name, Integer age, String mobile, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserExcelModel</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义这个对象的目的有两个：当前场景下写入文件作为model对象构造数据以及下个要讲的数据读取了。</p><p>「简要代码流程如下：」</p><p><strong>定义列标题-&gt;创建sheet-&gt;自定义字体和风格-&gt;构造数据-&gt;写入数据-&gt;写入到浏览器响应流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/exportData"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportData</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XSSFWorkbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line"></span><br><span class="line">        String []columnNames = &#123;<span class="string">"用户名"</span>,<span class="string">"年龄"</span>,<span class="string">"手机号"</span>,<span class="string">"性别"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Sheet sheet = workbook.createSheet();</span><br><span class="line">        Font titleFont = workbook.createFont();</span><br><span class="line">        titleFont.setFontName(<span class="string">"simsun"</span>);</span><br><span class="line">        titleFont.setBold(<span class="keyword">true</span>);</span><br><span class="line">        titleFont.setColor(IndexedColors.BLACK.index);</span><br><span class="line"></span><br><span class="line">        XSSFCellStyle titleStyle = workbook.createCellStyle();</span><br><span class="line">        titleStyle.setAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        titleStyle.setVerticalAlignment(VerticalAlignment.CENTER);</span><br><span class="line">        titleStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">        titleStyle.setFillForegroundColor(IndexedColors.YELLOW.index);</span><br><span class="line">        titleStyle.setFont(titleFont);</span><br><span class="line"></span><br><span class="line">        Row titleRow = sheet.createRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnNames.length; i++) &#123;</span><br><span class="line">            Cell cell = titleRow.createCell(i);</span><br><span class="line">            cell.setCellValue(columnNames[i]);</span><br><span class="line">            cell.setCellStyle(titleStyle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟构造数据</span></span><br><span class="line">        List&lt;UserExcelModel&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dataList.add(<span class="keyword">new</span> UserExcelModel(<span class="string">"张三"</span>,<span class="number">12</span>,<span class="string">"13867098765"</span>,<span class="string">"男"</span>));</span><br><span class="line">        dataList.add(<span class="keyword">new</span> UserExcelModel(<span class="string">"张三1"</span>,<span class="number">12</span>,<span class="string">"13867098765"</span>,<span class="string">"男"</span>));</span><br><span class="line">        dataList.add(<span class="keyword">new</span> UserExcelModel(<span class="string">"张三2"</span>,<span class="number">12</span>,<span class="string">"13867098765"</span>,<span class="string">"男"</span>));</span><br><span class="line">        dataList.add(<span class="keyword">new</span> UserExcelModel(<span class="string">"张三3"</span>,<span class="number">12</span>,<span class="string">"13867098765"</span>,<span class="string">"男"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数据行并写入值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dataList.size(); j++) &#123;</span><br><span class="line">            UserExcelModel userExcelModel = dataList.get(j);</span><br><span class="line">            <span class="keyword">int</span> lastRowNum = sheet.getLastRowNum();</span><br><span class="line">            Row dataRow = sheet.createRow(lastRowNum + <span class="number">1</span>);</span><br><span class="line">            dataRow.createCell(<span class="number">0</span>).setCellValue(userExcelModel.getName());</span><br><span class="line">            dataRow.createCell(<span class="number">1</span>).setCellValue(userExcelModel.getAge());</span><br><span class="line">            dataRow.createCell(<span class="number">2</span>).setCellValue(userExcelModel.getMobile());</span><br><span class="line">            dataRow.createCell(<span class="number">3</span>).setCellValue(userExcelModel.getSex());</span><br><span class="line">        &#125;</span><br><span class="line">        response.setContentType(<span class="string">"application/vnd.ms-excel"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"content-Disposition"</span>, <span class="string">"attachment;filename="</span> + URLEncoder.encode(<span class="string">"easyexcel.xls"</span>, <span class="string">"utf-8"</span>));</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Expose-Headers"</span>, <span class="string">"content-Disposition"</span>);</span><br><span class="line">        OutputStream outputStream = response.getOutputStream();</span><br><span class="line">        workbook.write(outputStream);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-读取数据"><a href="#3-读取数据" class="headerlink" title="3.读取数据"></a>3.读取数据</h3><p>我们再回过头来看我们定义的这个Model对象，通过指定index可以对应读取的excel里面的列，然后定义的数据类型就对应到excel里面具体的值，来看看如何实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/readExcel"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserExcelModel&gt; <span class="title">readExcel</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> MultipartFile file)</span>&#123;</span><br><span class="line">        List&lt;UserExcelModel&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list = EasyExcel.read(file.getInputStream(),UserExcelModel<span class="class">.<span class="keyword">class</span>,<span class="title">new</span> <span class="title">ModelExcelListener</span>()).<span class="title">sheet</span>().<span class="title">doReadSync</span>()</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看完代码是不是心里一万头草拟吗飞过~ 看完这个代码再看用poi工具处理的，是不是相当简洁了。对于代码中的ModelExcelListener,其实是我们自定义的一个读取监听类，贴贴代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelExcelListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Object&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过 AnalysisContext 对象还可以获取当前 sheet，当前行等数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//数据存储到list，供批量处理，或后续自己业务逻辑处理。</span></span><br><span class="line">            log.info(<span class="string">"读取到数据&#123;&#125;"</span>,data);</span><br><span class="line">            datas.add(data);</span><br><span class="line">            <span class="comment">//根据业务自行处理，可以写入数据库等等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所以的数据解析完了调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"所有数据解析完成"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一个读取数据监听类，有特殊业务需求的都可以在这个类里面自定义实现，比如边读边写库啊，数据过滤和处理等等，用的好了绝对是一把利剑。</p><h4 id="postman模拟调用"><a href="#postman模拟调用" class="headerlink" title="postman模拟调用"></a>postman模拟调用</h4><img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/postman.png" class="" title="postman模拟调用"><h4 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h4><img src="/2020/06/21/Java%E4%BD%BF%E7%94%A8easyexcel%E6%93%8D%E4%BD%9Cexcel/console.png" class="" title="控制台输出"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本篇文章，我们演示了如何使用easyexcel进行一些excel的操作，在实际的项目应用中，可以对以上示例代码进行进一步的封装，使其不管是读取、导出等操作都能几行代码搞定，这个就得根据情况大家自由发挥了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s/PyblQA4I9Wp9JT4ll2WcQA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PyblQA4I9Wp9JT4ll2WcQA</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理的十条建议</title>
      <link href="/2020/06/15/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E6%9D%A1%E5%BB%BA%E8%AE%AE/"/>
      <url>/2020/06/15/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E6%9D%A1%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java异常处理的十个建议，希望对大家有帮助~</p><h3 id="一、尽量不要使用e-printStackTrace-而是使用log打印。"><a href="#一、尽量不要使用e-printStackTrace-而是使用log打印。" class="headerlink" title="一、尽量不要使用e.printStackTrace(),而是使用log打印。"></a>一、尽量不要使用e.printStackTrace(),而是使用log打印。</h3><p><strong>反例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  &#x2F;&#x2F; do what you want  </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  &#x2F;&#x2F; do what you want  </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  log.info(&quot;你的程序有异常啦,&#123;&#125;&quot;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。</li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了,即内存满了，那么，用户的请求就卡住啦~</li></ul><h3 id="二、catch了异常，但是没有打印出具体的exception，无法更好定位问题"><a href="#二、catch了异常，但是没有打印出具体的exception，无法更好定位问题" class="headerlink" title="二、catch了异常，但是没有打印出具体的exception，无法更好定位问题"></a>二、catch了异常，但是没有打印出具体的exception，无法更好定位问题</h3><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  &#x2F;&#x2F; do what you want  </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  log.info(&quot;你的程序有异常啦&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  &#x2F;&#x2F; do what you want  </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  log.info(&quot;你的程序有异常啦，&#123;&#125;&quot;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>反例中，并没有把exception出来，到时候排查问题就不好查了啦，到底是SQl写错的异常还是IO异常，还是其他呢？所以应该把exception打印到日志中哦~</li></ul><h3 id="三、不要用一个Exception捕捉所有可能的异常"><a href="#三、不要用一个Exception捕捉所有可能的异常" class="headerlink" title="三、不要用一个Exception捕捉所有可能的异常"></a>三、不要用一个Exception捕捉所有可能的异常</h3><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;…抛出 IOException 的代码调用</span><br><span class="line">        &#x2F;&#x2F;…抛出 SQLException 的代码调用</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        &#x2F;&#x2F;用基类 Exception 捕捉的所有可能的异常，如果多个层次都这样捕捉，会丢失原始异常的有效信息哦</span><br><span class="line">        log.info(“Exception in test,exception:&#123;&#125;”, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;…抛出 IOException 的代码调用</span><br><span class="line">        &#x2F;&#x2F;…抛出 SQLException 的代码调用</span><br><span class="line">    &#125;catch(IOException e)&#123;</span><br><span class="line">        &#x2F;&#x2F;仅仅捕捉 IOException</span><br><span class="line">        log.info(“IOException in test,exception:&#123;&#125;”, e);</span><br><span class="line">    &#125;catch(SQLException e)&#123;</span><br><span class="line">        &#x2F;&#x2F;仅仅捕捉 SQLException</span><br><span class="line">        log.info(“SQLException in test,exception:&#123;&#125;”, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>用基类 Exception 捕捉的所有可能的异常，如果多个层次都这样捕捉，会丢失原始异常的有效信息哦</li></ul><h3 id="四、记得使用finally关闭流资源或者直接使用try-with-resource"><a href="#四、记得使用finally关闭流资源或者直接使用try-with-resource" class="headerlink" title="四、记得使用finally关闭流资源或者直接使用try-with-resource"></a>四、记得使用finally关闭流资源或者直接使用try-with-resource</h3><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fdIn &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    fdIn &#x3D; new FileInputStream(new File(&quot;&#x2F;jay.txt&quot;));</span><br><span class="line">    &#x2F;&#x2F;在这里关闭流资源？有没有问题呢？如果发生异常了呢？</span><br><span class="line">    fdIn.close();</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例1：</strong></p><p>需要使用finally关闭流资源，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fdIn &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    fdIn &#x3D; new FileInputStream(new File(&quot;&#x2F;jay.txt&quot;));</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fdIn !&#x3D; null) &#123;</span><br><span class="line">            fdIn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例2：</strong></p><p>当然，也可以使用JDK7的新特性try-with-resource来处理，它是Java7提供的一个新功能，它用于自动资源管理。</p><ul><li>资源是指在程序用完了之后必须要关闭的对象。</li><li>try-with-resources保证了每个声明了的资源在语句结束的时候会被关闭</li><li>什么样的对象才能当做资源使用呢？只要实现了java.lang.AutoCloseable接口或者java.io.Closeable接口的对象，都OK。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try (FileInputStream inputStream &#x3D; new FileInputStream(new File(&quot;jay.txt&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; use resources   </span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>如果不使用finally或者try-with-resource，当程序发生异常，IO资源流没关闭，那么这个IO资源就会被他一直占着，这样别人就没有办法用了，这就造成资源浪费。</li></ul><h3 id="五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类"><a href="#五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类" class="headerlink" title="五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类"></a>五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类</h3><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BizException 是 Exception 的子类</span><br><span class="line">public class BizException extends Exception &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;抛出父类Exception</span><br><span class="line">public static void test() throws Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    test(); &#x2F;&#x2F;编译错误</span><br><span class="line">&#125; catch (BizException e) &#123; &#x2F;&#x2F;捕获异常子类是没法匹配的哦</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抛出子类Exception</span><br><span class="line">public static void test() throws BizException &#123;&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、捕获到的异常，不能忽略它，至少打点日志吧"><a href="#六、捕获到的异常，不能忽略它，至少打点日志吧" class="headerlink" title="六、捕获到的异常，不能忽略它，至少打点日志吧"></a>六、捕获到的异常，不能忽略它，至少打点日志吧</h3><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void testIgnoreException() throws Exception &#123;</span><br><span class="line">    try &#123;       </span><br><span class="line">        &#x2F;&#x2F; 搞事情</span><br><span class="line">    &#125; catch (Exception e) &#123;     &#x2F;&#x2F;一般不会有这个异常</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void testIgnoreException() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 搞事情</span><br><span class="line">    &#125; catch (Exception e) &#123;     &#x2F;&#x2F;一般不会有这个异常</span><br><span class="line">        log.error(&quot;这个异常不应该在这里出现的,&#123;&#125;&quot;,e); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>虽然一个正常情况都不会发生的异常，但是如果你捕获到它，就不要忽略呀，至少打个日志吧~</li></ul><h3 id="七、注意异常对你的代码层次结构的侵染（早发现早处理）"><a href="#七、注意异常对你的代码层次结构的侵染（早发现早处理）" class="headerlink" title="七、注意异常对你的代码层次结构的侵染（早发现早处理）"></a>七、注意异常对你的代码层次结构的侵染（早发现早处理）</h3><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public UserInfo queryUserInfoByUserId(Long userid) throw SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F;根据用户Id查询数据库</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public UserInfo queryUserInfoByUserId(Long userid) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;根据用户Id查询数据库</span><br><span class="line">    &#125;catch(SQLException e)&#123;</span><br><span class="line">        log.error(&quot;查询数据库异常啦，&#123;&#125;&quot;,e);</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        &#x2F;&#x2F;关闭连接，清理资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>我们的项目，一般都会把代码分 Action、Service、Dao 等不同的层次结构，如果你是DAO层处理的异常，尽早处理吧，如果往上 throw SQLException，上层代码就还是要try catch处理啦，这就污染了你的代码~</li></ul><h3 id="八、自定义封装异常，不要丢弃原始异常的信息Throwable-cause"><a href="#八、自定义封装异常，不要丢弃原始异常的信息Throwable-cause" class="headerlink" title="八、自定义封装异常，不要丢弃原始异常的信息Throwable cause"></a>八、自定义封装异常，不要丢弃原始异常的信息Throwable cause</h3><p>我们常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。公司的框架提供统一异常处理就用到异常链，我们自定义封装异常，不要丢弃原始异常的信息，否则排查问题就头疼啦</p><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class TestChainException &#123;</span><br><span class="line">    public void readFile() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream is &#x3D; new FileInputStream(&quot;jay.txt&quot;);</span><br><span class="line">            Scanner in &#x3D; new Scanner(is);</span><br><span class="line">            while (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;e 保存异常信息</span><br><span class="line">            throw new MyException(&quot;文件在哪里呢&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void invokeReadFile() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            readFile();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;e 保存异常信息</span><br><span class="line">            throw new MyException(&quot;文件找不到&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestChainException t &#x3D; new TestChainException();</span><br><span class="line">        try &#123;</span><br><span class="line">            t.invokeReadFile();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;MyException 构造器</span><br><span class="line">public MyException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，没有了Throwable cause，不好排查是什么异常了啦</p><img src="/2020/06/15/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E6%9D%A1%E5%BB%BA%E8%AE%AE/exception1.png" class="" title="exception before"><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TestChainException &#123;</span><br><span class="line">    public void readFile() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream is &#x3D; new FileInputStream(&quot;jay.txt&quot;);</span><br><span class="line">            Scanner in &#x3D; new Scanner(is);</span><br><span class="line">            while (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;e 保存异常信息</span><br><span class="line">            throw new MyException(&quot;文件在哪里呢&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void invokeReadFile() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            readFile();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;e 保存异常信息</span><br><span class="line">            throw new MyException(&quot;文件找不到&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestChainException t &#x3D; new TestChainException();</span><br><span class="line">        try &#123;</span><br><span class="line">            t.invokeReadFile();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;MyException 构造器</span><br><span class="line">public MyException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/15/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E6%9D%A1%E5%BB%BA%E8%AE%AE/exception2.png" class="" title="exception after"><h3 id="九、运行时异常RuntimeException-，不应该通过catch-的方式来处理，而是先预检查，比如：NullPointerException处理"><a href="#九、运行时异常RuntimeException-，不应该通过catch-的方式来处理，而是先预检查，比如：NullPointerException处理" class="headerlink" title="九、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理"></a>九、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理</h3><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  obj.method() </span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (obj !&#x3D; null)&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十、注意异常匹配的顺序，优先捕获具体的异常"><a href="#十、注意异常匹配的顺序，优先捕获具体的异常" class="headerlink" title="十、注意异常匹配的顺序，优先捕获具体的异常"></a>十、注意异常匹配的顺序，优先捕获具体的异常</h3><p>注意异常的匹配顺序，因为只有第一个匹配到异常的catch块才会被执行。如果你希望看到，是NumberFormatException异常，就抛出NumberFormatException，如果是IllegalArgumentException就抛出IllegalArgumentException。</p><p><strong>反例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    doSomething(&quot;test exception&quot;);</span><br><span class="line">&#125; catch (IllegalArgumentException e) &#123;       </span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    doSomething(&quot;test exception&quot;);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;       </span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>因为NumberFormatException是IllegalArgumentException 的子类，反例中，不管是哪个异常，都会匹配到IllegalArgumentException，就不会再往下执行啦，因此不知道是否是NumberFormatException。所以需要优先捕获具体的异常，把NumberFormatException放前面~</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5ee45107f265da770952788f" target="_blank" rel="noopener">https://juejin.im/post/5ee45107f265da770952788f</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实现通过url下载pdf到本地</title>
      <link href="/2020/06/06/SpringBoot%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%BF%87url%E4%B8%8B%E8%BD%BDpdf%E5%88%B0%E6%9C%AC%E5%9C%B0/"/>
      <url>/2020/06/06/SpringBoot%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%BF%87url%E4%B8%8B%E8%BD%BDpdf%E5%88%B0%E6%9C%AC%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<p>最近有需求是点击下载按钮后下载指定url的pdf文件到本地</p><p>下面通过<strong>SpringBoot</strong>来实现一下：</p><a id="more"></a><h4 id="思路就是："><a href="#思路就是：" class="headerlink" title="思路就是："></a><strong>思路</strong>就是：</h4><ol><li>解析url，建立连接获取输入流</li><li>copy输入流到输出流中，进行相关设置并返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/download"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(@RequestParam(<span class="string">"url"</span>)</span> String urlStr, HttpServletResponse response) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">        <span class="comment">//设置超时间为5秒</span></span><br><span class="line"><span class="comment">//        conn.setConnectTimeout(5*1000);</span></span><br><span class="line">        <span class="comment">//防止屏蔽程序抓取而返回403错误</span></span><br><span class="line">        conn.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)"</span>);</span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = conn.getInputStream();</span><br><span class="line">            OutputStream outputStream = response.getOutputStream();) &#123;</span><br><span class="line">            response.setContentType(<span class="string">"application/x-download"</span>);</span><br><span class="line">            response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename=test.pdf"</span>);</span><br><span class="line">            <span class="comment">// 将输入流拷贝到输出流中</span></span><br><span class="line">            IOUtils.copy(inputStream, outputStream);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Boot多数据源的动态切换</title>
      <link href="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/"/>
      <url>/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="创建数据库和数据表"><a href="#创建数据库和数据表" class="headerlink" title="创建数据库和数据表"></a>创建数据库和数据表</h3><p>首先需要建立两个库进行测试，我这里使用的是master_test和slave_test两个库，</p><p>两个库都有一张同样的表，表名tuser</p><a id="more"></a><img src="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/master_table.png" class="" title="master table"><img src="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/slave_table.png" class="" title="slave table"><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        添加druid数据源--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--        添加aop--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><h4 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 11:08 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2470170238667716941L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy= GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"id"</span>, unique=<span class="keyword">true</span>, nullable=<span class="keyword">false</span>, precision=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"name"</span>, precision=<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tuser repository</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 11:07 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TuserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Tuser</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态数据源配置"><a href="#动态数据源配置" class="headerlink" title="动态数据源配置"></a>动态数据源配置</h3><p>这里使用的数据源为druid，实现数据源之间的切换用@DataSource自定义注解，配置Aop进行切换 application.yml 配置文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">wgl-master:</span></span><br><span class="line">        <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://101.200.63.11:3306/master_test?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">      <span class="attr">wgl-slave:</span></span><br><span class="line">        <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://101.200.63.11:3306/slave_test?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br></pre></td></tr></table></figure><h3 id="多数据源配置类"><a href="#多数据源配置类" class="headerlink" title="多数据源配置类"></a>多数据源配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 10:55 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.druid.wgl-master"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">wglMasterDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.druid.wgl-slave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource  <span class="title">wglSlaveDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicDataSource <span class="title">dataSource</span><span class="params">(DataSource wglMasterDataSource, DataSource wglSlaveDataSource)</span> </span>&#123;</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        targetDataSources.put(<span class="string">"wgl-master"</span>,wglMasterDataSource);</span><br><span class="line">        targetDataSources.put(<span class="string">"wgl-slave"</span>, wglSlaveDataSource);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicDataSource(wglMasterDataSource, targetDataSources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态数据源切换类"><a href="#动态数据源切换类" class="headerlink" title="动态数据源切换类"></a>动态数据源切换类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态数据源切换类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 10:57 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span>  <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; contextHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicDataSource</span><span class="params">(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDefaultTargetDataSource(defaultTargetDataSource);</span><br><span class="line">        <span class="keyword">super</span>.setTargetDataSources(targetDataSources);</span><br><span class="line">        <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dataSource)</span> </span>&#123;</span><br><span class="line">        contextHolder.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义-DataSource注解"><a href="#自定义-DataSource注解" class="headerlink" title="自定义@DataSource注解"></a>自定义@DataSource注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义数据源选择注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 10:58 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataSource &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Aop切面类配置"><a href="#Aop切面类配置" class="headerlink" title="Aop切面类配置"></a>Aop切面类配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Aop切面类配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 11:01 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.wgl.cupid.annotation.DataSource)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataSourcePointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"dataSourcePointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        DataSource dataSource = method.getAnnotation(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(dataSource == <span class="keyword">null</span>)&#123;</span><br><span class="line">            DynamicDataSource.setDataSource(<span class="string">"wgl-master"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            DynamicDataSource.setDataSource(dataSource.name());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DynamicDataSource.clearDataSource();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动配置注解信息，重要（不然运行会报错）"><a href="#启动配置注解信息，重要（不然运行会报错）" class="headerlink" title="启动配置注解信息，重要（不然运行会报错）"></a>启动配置注解信息，重要（不然运行会报错）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude= &#123;DataSourceAutoConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;DynamicDataSourceConfig<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CupidApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CupidApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试controller"><a href="#测试controller" class="headerlink" title="测试controller"></a>测试controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Guolong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30 11:04 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicUserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TuserRepository tuserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list/slave"</span>)</span><br><span class="line">    <span class="meta">@DataSource</span>(name = <span class="string">"wgl-slave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Tuser&gt; <span class="title">listSlave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuserRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list/master"</span>)</span><br><span class="line">    <span class="meta">@DataSource</span>(name = <span class="string">"wgl-master"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Tuser&gt; <span class="title">listMaster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuserRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><h4 id="http-localhost-8080-list-master"><a href="#http-localhost-8080-list-master" class="headerlink" title="http://localhost:8080/list/master"></a><a href="http://localhost:8080/list/master" target="_blank" rel="noopener">http://localhost:8080/list/master</a></h4><img src="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/master_result.png" class="" title="master result"><h4 id="http-localhost-8080-list-slave"><a href="#http-localhost-8080-list-slave" class="headerlink" title="http://localhost:8080/list/slave"></a><a href="http://localhost:8080/list/slave" target="_blank" rel="noopener">http://localhost:8080/list/slave</a></h4><img src="/2020/05/30/Spring-Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/slave_result.png" class="" title="slave result"><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://mp.weixin.qq.com/s/HNr97Fqonq3SZkJj21cDlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HNr97Fqonq3SZkJj21cDlg</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题记录-1</title>
      <link href="/2020/05/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95-1/"/>
      <url>/2020/05/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95-1/</url>
      
        <content type="html"><![CDATA[<h2 id="根据exercise表写sql语句"><a href="#根据exercise表写sql语句" class="headerlink" title="根据exercise表写sql语句"></a>根据exercise表写sql语句</h2><h3 id="exercise表设计："><a href="#exercise表设计：" class="headerlink" title="exercise表设计："></a>exercise表设计：</h3><img src="/2020/05/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95-1/%E8%AE%BE%E8%AE%A1%E8%A1%A8.png" class="" title="设计表"><h3 id="exercise表数据："><a href="#exercise表数据：" class="headerlink" title="exercise表数据："></a>exercise表数据：</h3><img src="/2020/05/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95-1/%E8%A1%A8%E6%95%B0%E6%8D%AE.png" class="" title="表数据"><a id="more"></a><h3 id="问题1-查找答对题目最多的前两名用户ID"><a href="#问题1-查找答对题目最多的前两名用户ID" class="headerlink" title="问题1 查找答对题目最多的前两名用户ID"></a>问题1 查找答对题目最多的前两名用户ID</h3><p>SELECT user_id FROM exercise WHERE correct = 1 GROUP BY user_id ORDER BY count(*) DESC LIMIT 2;</p><h3 id="问题2-查找被作答次数前两名的题目ID"><a href="#问题2-查找被作答次数前两名的题目ID" class="headerlink" title="问题2 查找被作答次数前两名的题目ID"></a>问题2 查找被作答次数前两名的题目ID</h3><p>SELECT question_id FROM exercise GROUP BY question_id ORDER BY count(*) DESC LIMIT 2;</p><h2 id="数据表的索引如何设计？"><a href="#数据表的索引如何设计？" class="headerlink" title="数据表的索引如何设计？"></a>数据表的索引如何设计？</h2><h3 id="选择唯一性索引"><a href="#选择唯一性索引" class="headerlink" title="选择唯一性索引"></a>选择唯一性索引</h3><ul><li>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录</li></ul><h3 id="为常作为查询条件的字段建立索引"><a href="#为常作为查询条件的字段建立索引" class="headerlink" title="为常作为查询条件的字段建立索引"></a>为常作为查询条件的字段建立索引</h3><ul><li>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建⽴立索引，可以提⾼高整个表的查询速度</li></ul><h3 id="限制索引的数目"><a href="#限制索引的数目" class="headerlink" title="限制索引的数目"></a>限制索引的数目</h3><ul><li>索引的数目不是越多越好</li><li>每个索引都需要占⽤用磁盘空间，索引越多，需要的磁盘空间就越大</li><li>修改表时，对索引的重构和更新很麻烦</li><li>越多的索引，会使更新表变得很浪费时间</li></ul><h3 id="尽量使用数据量少的索引"><a href="#尽量使用数据量少的索引" class="headerlink" title="尽量使用数据量少的索引"></a>尽量使用数据量少的索引</h3><ul><li>如果索引的值很长，那么查询的速度会受到影响</li><li><ul><li>例如：对一个char(100)类型的字段进行全文检索需要的时间肯定比对char(10)类型的字段需要的时间更多</li></ul></li></ul><h3 id="为经常需要排序、分组和联合操作的字段建立索引"><a href="#为经常需要排序、分组和联合操作的字段建立索引" class="headerlink" title="为经常需要排序、分组和联合操作的字段建立索引"></a>为经常需要排序、分组和联合操作的字段建立索引</h3><ul><li>经常需要order by、group by、distinct和union等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效的避免排序操作</li></ul><h3 id="尽量使用前缀索引"><a href="#尽量使用前缀索引" class="headerlink" title="尽量使用前缀索引"></a>尽量使用前缀索引</h3><ul><li>如果索引字段的值很长，最好使用值的前缀来索引</li><li><ul><li>例如：text和blog类型的字段，进行全文检索会浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度</li></ul></li></ul><h3 id="删除不再使用或者很少使用的索引"><a href="#删除不再使用或者很少使用的索引" class="headerlink" title="删除不再使用或者很少使用的索引"></a>删除不再使用或者很少使用的索引</h3><ul><li>表中数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理理员应当定期找出这些索引，将他们删除，从而减少索引对更新操作的影响</li></ul><h3 id="小表不应建议索引-超过200w数据的表，建立索引"><a href="#小表不应建议索引-超过200w数据的表，建立索引" class="headerlink" title="小表不应建议索引(超过200w数据的表，建立索引)"></a>小表不应建议索引(超过200w数据的表，建立索引)</h3><ul><li>包含大量的列并且不需要搜索非空值的时候可以考虑不建索引</li></ul><h3 id="经常被用来过滤记录的字段"><a href="#经常被用来过滤记录的字段" class="headerlink" title="经常被用来过滤记录的字段"></a>经常被用来过滤记录的字段</h3><ul><li>primary key 字段，系统自动创建主键的索引</li><li>unique key 字段，系统自动创建对应的索引</li><li>foreign key 约束所定义的作为外键的字段</li><li>在查询中用来连接表的字段</li><li>经常用来作为排序(order by的字段)基准的字段</li></ul><h3 id="索引会占⽤用磁盘空间，创建不不必要的索引只会形成浪费"><a href="#索引会占⽤用磁盘空间，创建不不必要的索引只会形成浪费" class="headerlink" title="索引会占⽤用磁盘空间，创建不不必要的索引只会形成浪费"></a>索引会占⽤用磁盘空间，创建不不必要的索引只会形成浪费</h3><h3 id="索引的创建必须考虑数据的操作方式"><a href="#索引的创建必须考虑数据的操作方式" class="headerlink" title="索引的创建必须考虑数据的操作方式"></a>索引的创建必须考虑数据的操作方式</h3><ul><li>内容很少变动，经常被查询，为它多创建几个索引无所谓</li><li>经常性，例行性变动的表而言，则需要谨慎地创建确实必要的索引</li></ul><h2 id="如何保障mysql和redis之间的数据一致性？"><a href="#如何保障mysql和redis之间的数据一致性？" class="headerlink" title="如何保障mysql和redis之间的数据一致性？"></a>如何保障mysql和redis之间的数据一致性？</h2><p><a href="https://zhuanlan.zhihu.com/p/91770135" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91770135</a></p><p><a href="https://juejin.im/post/5c96fb795188252d5f0fdff2" target="_blank" rel="noopener">https://juejin.im/post/5c96fb795188252d5f0fdff2</a></p><h2 id="实现算法：反转链表"><a href="#实现算法：反转链表" class="headerlink" title="实现算法：反转链表"></a>实现算法：反转链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归方法</span></span><br><span class="line"><span class="comment">     * recursive</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList_recursive</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverseList_recursive(head.next);</span><br><span class="line">        <span class="comment">// 反转箭头</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法</span></span><br><span class="line"><span class="comment">     * iterative</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList_iterative</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用java实现一个线程安全的单例模式"><a href="#用java实现一个线程安全的单例模式" class="headerlink" title="用java实现一个线程安全的单例模式"></a>用java实现一个线程安全的单例模式</h2><h3 id="推荐使用枚举"><a href="#推荐使用枚举" class="headerlink" title="推荐使用枚举"></a>推荐使用枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型是线程安全的，并且只会装载一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SingletonObject instance;</span><br><span class="line"></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> SingletonObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h2><p>==对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</p><p>而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h2 id="Mysql查询性能优化"><a href="#Mysql查询性能优化" class="headerlink" title="Mysql查询性能优化"></a>Mysql查询性能优化</h2><p><a href="https://segmentfault.com/a/1190000011330649" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011330649</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面试常见问题-2</title>
      <link href="/2020/05/08/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2/"/>
      <url>/2020/05/08/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2/</url>
      
        <content type="html"><![CDATA[<h3 id="搜索引擎的工作原理"><a href="#搜索引擎的工作原理" class="headerlink" title="搜索引擎的工作原理"></a>搜索引擎的工作原理</h3><p>各个搜索引擎都有叫做“蜘蛛”的机器人，这些机器人负责在网络上收集网站上的各种各样的信息。</p><p>每个网站都有非常多的链接，有的是链接到网站内容页面的，有的是链接到其他网站的，搜索引擎的蜘蛛就会顺着这些链接爬下去，把符合标准的网页搬回自己的数据库，这也就是搜索引擎能给我们提供成千上万个结果的原因了。</p><p>这就完成了第一部分的工作，这又怎么样快速的从搜索引擎中找到我们想要的东西呢？</p><a id="more"></a><p>第二步就是建立索引，这个就像是书的目录一样。一般来讲，搜索引擎会分析网页的关键词，有关键字的并且出现多次的在结果中就会比较靠前。然后这个网站是不是一个人气高的网站，打开速度快不快等等，各种各样的因素都会影响搜索引擎给网站的评分，从而影响网站在搜索结果中的排名。</p><p>这就是搜索引擎大概的工作原理。</p><h3 id="JDK和JRE的区别是什么"><a href="#JDK和JRE的区别是什么" class="headerlink" title="JDK和JRE的区别是什么"></a>JDK和JRE的区别是什么</h3><p>JDK: <strong>java开发工具包</strong>,包含了JRE、编译器和其它工具（如：javaDoc、java调试器)</p><p>JRE: <strong>java运行环境</strong>,包含java虚拟机和java程序所需的核心类库。</p><p>如果只是想跑java程序，那么只需安装JRE，如果要写java程序并且运行，那就需要JDK了。</p><h3 id="Java支持多继承么？如果不支持，如何实现"><a href="#Java支持多继承么？如果不支持，如何实现" class="headerlink" title="Java支持多继承么？如果不支持，如何实现?"></a>Java支持多继承么？如果不支持，如何实现?</h3><p>在java中是单继承的，也就是说一个类只能继承一个父类。</p><p>java中实现多继承有两种方式,一是<strong>接口</strong>，而是<strong>内部类</strong>.</p><h3 id="JVM内存分哪几个区，每个区的作用是什么"><a href="#JVM内存分哪几个区，每个区的作用是什么" class="headerlink" title="JVM内存分哪几个区，每个区的作用是什么?"></a>JVM内存分哪几个区，每个区的作用是什么?</h3><p>java虚拟机主要分为以下几个区:</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载</p><p><strong>方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</strong></p><p>该区域是被线程共享的。</p><p>方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p><strong>虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</strong></p><p>虚拟机栈是线程私有的，它的生命周期与线程相同。</p><p>局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p><p>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈和虚拟机栈类似，只不过<strong>本地方法栈为Native方法服务</strong>。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>java堆是所有线程所共享的一块内存，在虚拟机启动时创建，<strong>几乎所有的对象实例都在这里创建</strong>，因此该区域经常发生垃圾回收操作。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><strong>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。</strong>该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>java内存模型(JMM)是线程间通信的控制机制.<strong>JMM定义了主内存和线程之间抽象关系</strong>。</p><p>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</p><p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p><img src="/2020/05/08/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" class="" title="Java内存模型"><p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p><p>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</p><p>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</p><h3 id="简述java垃圾回收机制"><a href="#简述java垃圾回收机制" class="headerlink" title="简述java垃圾回收机制?"></a>简述java垃圾回收机制?</h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h3 id="java中垃圾收集的方法有哪些"><a href="#java中垃圾收集的方法有哪些" class="headerlink" title="java中垃圾收集的方法有哪些?"></a>java中垃圾收集的方法有哪些?</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除:"></a>标记-清除:</h4><p>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法:"></a>复制算法:</h4><p>为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。</p><p>于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理:"></a>标记-整理:</h4><p>该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</p><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集:"></a>分代收集:</h4><p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p><h3 id="类加载器双亲委派模型机制？"><a href="#类加载器双亲委派模型机制？" class="headerlink" title="类加载器双亲委派模型机制？"></a>类加载器双亲委派模型机制？</h3><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p><h3 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h3><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><p><strong>启动类加载器</strong>(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。<br><strong>扩展类加载器</strong>(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br><strong>系统类加载器</strong>（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。<br><strong>用户自定义类加载器</strong>，通过继承 java.lang.ClassLoader类的方式实现。</p><h3 id="HashMap的工作原理是什么"><a href="#HashMap的工作原理是什么" class="headerlink" title="HashMap的工作原理是什么?"></a>HashMap的工作原理是什么?</h3><p>HashMap内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个Entry实体(jdk 8为Node)，这个Entry实体主要包含key、value以及一个指向自身的next指针。</p><p>HashMap是基于hashing实现的，当我们进行put操作时，根据传递的key值得到它的hashcode，然后再用这个hashcode与数组的长度进行模运算，得到一个int值，就是Entry要存储在数组的位置（下标）；</p><p>当通过get方法获取指定key的值时，会根据这个key算出它的hash值（数组下标），根据这个hash值获取数组下标对应的Entry，然后判断Entry里的key，hash值或者通过equals()比较是否与要查找的相同，如果相同，返回value，否则的话，遍历该链表（有可能就只有一个Entry，此时直接返回null），直到找到为止，否则返回null。</p><p>HashMap之所以在每个数组元素存储的是一个链表，是为了解决hash冲突问题，当两个对象的hash值相等时，那么一个位置肯定是放不下两个值的，于是hashmap采用链表来解决这种冲突，hash值相等的两个元素会形成一个链表。</p><h3 id="CorrentHashMap的工作原理"><a href="#CorrentHashMap的工作原理" class="headerlink" title="CorrentHashMap的工作原理?"></a>CorrentHashMap的工作原理?</h3><p>jdk 1.6版: ConcurrenHashMap可以说是HashMap的升级版，ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。</p><p>具体实现:ConcurrentHashMap内部有一个Segment&lt;K,V&gt;数组,该Segment对象可以充当锁。Segment对象内部有一个HashEntry&lt;K,V&gt;数组，于是每个Segment可以守护若干个桶(HashEntry),每个桶又有可能是一个HashEntry连接起来的链表，存储发生碰撞的元素。</p><p>每个ConcurrentHashMap在默认并发级下会创建包含16个Segment对象的数组，每个数组有若干个桶，当我们进行put方法时，通过hash方法对key进行计算，得到hash值，找到对应的segment，然后对该segment进行加锁，然后调用segment的put方法进行存储操作，此时其他线程就不能访问当前的segment，但可以访问其他的segment对象，不会发生阻塞等待。</p><p>jdk 1.8版 在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p><h3 id="fail-fast与fail-safe有什么区别？"><a href="#fail-fast与fail-safe有什么区别？" class="headerlink" title="fail-fast与fail-safe有什么区别？"></a>fail-fast与fail-safe有什么区别？</h3><p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。</p><p>Java.util包中的所有集合类都被设计为fail-&gt;fast的，而java.util.concurrent中的集合类都为fail-safe的。</p><p>当检测到正在遍历的集合的结构被改变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p><h3 id="RandomAccess是什么？"><a href="#RandomAccess是什么？" class="headerlink" title="RandomAccess是什么？"></a>RandomAccess是什么？</h3><p>RandomAccess接口是一个标记接口，用以标记实现的List集合具备快速随机访问的能力。</p><p>那么什么是随机访问的能力呢？其实很简单，随机访问就是随机的访问List中的任何一个元素。</p><p>ArrayList实现了RandomAccess接口，而LinkedList没有。</p><p>那么到底这个接口有什么用呢？</p><p><strong>当一个List拥有快速访问功能时，其遍历方法采用for循环最快速。而没有快速访问功能的List，遍历的时候采用Iterator迭代器最快速。</strong></p><p>当我们不明确获取到的是Arraylist，还是LinkedList的时候，我们可以通过RandomAccess来判断其是否支持快速随机访问，若支持则采用for循环遍历，否则采用迭代器遍历，</p><p>那么都有哪些类实现了这个接口呢？</p><ul><li>ArrayList</li><li>Vector</li><li>CopyOnWriteArrayList</li><li>RandomAccessSubList</li><li>UnmodifiableArrayList</li></ul><h3 id="HashSet的底层实现是什么"><a href="#HashSet的底层实现是什么" class="headerlink" title="HashSet的底层实现是什么?"></a>HashSet的底层实现是什么?</h3><p>通过看源码知道HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。</p><h3 id="LinkedHashMap的实现原理"><a href="#LinkedHashMap的实现原理" class="headerlink" title="LinkedHashMap的实现原理?"></a>LinkedHashMap的实现原理?</h3><p>LinkedHashMap也是基于HashMap实现的，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p><h3 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run() 方法有什么区别？"></a>Thread 类中的start() 和 run() 方法有什么区别？</h3><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p><h3 id="为什么wait-notify-和-notifyAll这些方法不在thread类里面"><a href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在thread类里面?"></a>为什么wait, notify 和 notifyAll这些方法不在thread类里面?</h3><p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.jianshu.com/p/04c0d796d877" target="_blank" rel="noopener">https://www.jianshu.com/p/04c0d796d877</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面试常见问题-1</title>
      <link href="/2020/05/04/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/"/>
      <url>/2020/05/04/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-String-StringBuilder-StringBuffer区别"><a href="#1-String-StringBuilder-StringBuffer区别" class="headerlink" title="1. String, StringBuilder, StringBuffer区别"></a>1. String, StringBuilder, StringBuffer区别</h2><p>这三个类的主要区别在两个方面：<strong>运算速度</strong>（运算性能或执行效率）和<strong>线程安全性</strong>。</p><h3 id="1-运算速度比较（通常情况下）：StringBuilder-gt-StringBuffer-gt-String"><a href="#1-运算速度比较（通常情况下）：StringBuilder-gt-StringBuffer-gt-String" class="headerlink" title="1. 运算速度比较（通常情况下）：StringBuilder &gt; StringBuffer &gt; String"></a>1. <strong>运算速度</strong>比较（通常情况下）：<strong>StringBuilder &gt; StringBuffer &gt; String</strong></h3><a id="more"></a><p>String是<strong>final</strong>类不能被继承且为字符串常量，而StringBuilder和StringBuffer均为<strong>字符串变量</strong>。String对象一旦创建便<strong>不可更改</strong>，而后两者是<strong>可更改</strong>的，它们只能通过构造函数来建立对象，且对象被建立以后将在内存中分配内存空间，并初始保存一个null，通过append方法向StringBuffer和StringBuilder中赋值。</p><p>Java中对String对象进行的操作实际上是一个不断创建并回收对象的过程，因此在运行速度上很慢。</p><h3 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2. 线程安全性"></a>2. 线程安全性</h3><p>StringBuilder（<strong>非线程安全</strong>）</p><p>而StringBuilder的方法没有该关键字修饰，所以不能保证线程安全性。</p><p>StringBuffer（<strong>线程安全的</strong>）</p><p>StringBuffer中大部分方法由<strong>synchronized</strong>关键字修饰，在必要时可对方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致，所以是线程安全的。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>String：适用于<strong>少量</strong>的字符串操作。</p><p>StringBuilder：适用于<strong>单线程</strong>下在字符串缓冲区进行大量操作。</p><p>StringBuffer：适用于<strong>多线程</strong>下在字符串缓冲区进行大量操作。</p><h2 id="2-Spring-Bean为什么是单例"><a href="#2-Spring-Bean为什么是单例" class="headerlink" title="2. Spring Bean为什么是单例"></a>2. Spring Bean为什么是单例</h2><h3 id="单例bean与原型bean的区别"><a href="#单例bean与原型bean的区别" class="headerlink" title="单例bean与原型bean的区别"></a>单例bean与原型bean的区别</h3><p><strong>单例：</strong>一个bean被声明为单例时，处理多次请求时spring容器里只实例化一个bean，后续的请求公用这个对象，这个对象存储在一个map中，当有请求时，先在缓存中（map）查找是否存在，存在则使用，不存在才实例化一个对象</p><p><strong>原型：</strong>每当有请求来就实例化一个新的bean，没有缓存以及从缓存中查</p><h4 id="单例bean的优势"><a href="#单例bean的优势" class="headerlink" title="单例bean的优势"></a>单例bean的优势</h4><p>由于不会每次都新创建新对象所以有一下几个性能上的优势：</p><p><strong>减少了新生成实例的消耗</strong></p><p>新生成实例消耗包括两方面，第一，spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。</p><p><strong>减少jvm垃圾回收</strong></p><p>由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。</p><p><strong>可以快速获取到bean</strong></p><p>因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。</p><h3 id="单例bean的劣势"><a href="#单例bean的劣势" class="headerlink" title="单例bean的劣势"></a>单例bean的劣势</h3><p>单例的bean一个很大的劣势就是他不能做到线程安全，由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试题：Spring 为啥把bean默认设计成单例？</p><p>答案：</p><p>为了提高性能<br>少创建实例<br>垃圾回收<br>缓存快速获取</p><p>单例有啥劣势？</p><p>如果是有状态的话在并发环境下线程不安全。</p><h2 id="3-项目中有用到多线程嘛"><a href="#3-项目中有用到多线程嘛" class="headerlink" title="3. 项目中有用到多线程嘛"></a>3. 项目中有用到多线程嘛</h2><p>用户注册完成送大礼包/积分之类，且积分等也是另一个系统并<strong>比较耗时</strong>；且这类任务即使失败也不是特别重要的。</p><p>后台线程：比如<strong>定期执行</strong>一些特殊任务，如定期更新配置文件，任务调度（如quartz），一些监控用于定期信息采集等。</p><p>特别耗时的操作，如备份数据库，可以开个线程执行备份，然后执行返回，前台不断向后台询问线程执行状态</p><p>场景一:一个业务逻辑有很多次的循环，<strong>每次循环之间没有影响</strong>，比如验证1万条url路径是否存在，正常情况要循环1万次，逐个去验证每一条URL，这样效率会很低，假设验证一条需要1分钟，总共就需要1万分钟，有点恐怖。这时可以用多线程，将1万条URL分成50等份，开50个线程，没个线程只需验证200条，这样所有的线程执行完是远小于1万分钟的。</p><p>场景二:需要知道一个任务的执行进度，比如我们常看到的进度条，实现方式可以是在任务中加入一个整型属性变量(这样不同方法可以共享)，任务执行一定程度就给变量值加1，另外开一个线程按时间间隔不断去访问这个变量，并反馈给用户。</p><p>总之<strong>使用多线程就是为了充分利用cpu的资源，提高程序执行效率</strong>，当你发现一个业务逻辑执行效率特别低，耗时特别长，就可以考虑使用多线程。<strong>不过CPU执行哪个线程的时间和顺序是不确定的</strong>，即使设置了线程的优先级，因此使用多线程的风险也是比较大的，会出现很多预料不到的问题，一定要多熟悉概念，多构造不同的场景去测试才能够掌握!</p><h2 id="4-HashMap为什么要重写hashCode和equals方法"><a href="#4-HashMap为什么要重写hashCode和equals方法" class="headerlink" title="4. HashMap为什么要重写hashCode和equals方法"></a>4. HashMap为什么要重写hashCode和equals方法</h2><p>HashMap和Hashtable的底层实现都是数组+链表结构实现的</p><p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。</p><p>如果你重载了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。</p><p>这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。</p><p>对于每一个对象，通过其hashCode()方法可为其生成一个整形值（散列码），该整型值被处理后，将会作为数组下标，存放该对象所对应的Entry（存放该对象及其对应值）。 </p><p>equals()方法则是在HashMap中插入值或查询时会使用到。当HashMap中插入值或查询值对应的散列码与数组中的散列码相等时，则会通过equals方法比较key值是否相等</p><p>所以想以自建对象作为HashMap的key，必须重写该对象继承object的hashCode和equals方法。</p><h2 id="5-Java集合中为什么要使用设计迭代器"><a href="#5-Java集合中为什么要使用设计迭代器" class="headerlink" title="5. Java集合中为什么要使用设计迭代器"></a>5. Java集合中为什么要使用设计迭代器</h2><p>优点: </p><pre><code>1. 可以不了解集合内部的数据结构,就可以直接遍历;2. **不暴露内部的数据**,可以直接外部遍历;3. 适用性强,基本上的集合都能使用迭代器;</code></pre><h2 id="6-为什么使用迭代器遍历删除是安全的"><a href="#6-为什么使用迭代器遍历删除是安全的" class="headerlink" title="6. 为什么使用迭代器遍历删除是安全的"></a>6. 为什么使用迭代器遍历删除是安全的</h2><p>基本上<strong>ArrayList采用size属性来维护自已的状态，而Iterator采用cursor来来维护自已的状态</strong>。</p><p>当size出现变化时，cursor并不一定能够得到同步，除非这种变化是Iterator主动导致的。</p><p>当Iterator.remove方法导致ArrayList列表发生变化时，他会更新cursor来同步这一变化。但其他方式导致的ArrayList变化，Iterator是无法感知的。ArrayList自然也不会主动通知Iterator们，那将是一个繁重的工作。Iterator到底还是做了努力：为了防止状态不一致可能引发的无法设想的后果，Iterator会经常做checkForComodification检查，以防有变。如果有变，则以异常抛出，所以就出现了上面的异常。</p><h2 id="7-Spring事务传播机制"><a href="#7-Spring事务传播机制" class="headerlink" title="7. Spring事务传播机制"></a>7. Spring事务传播机制</h2><ul><li>@Transactional(propagation=Propagation.REQUIRED)<br>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)</li><li>@Transactional(propagation=Propagation.NOT_SUPPORTED)<br>容器不为这个方法开启事务</li><li>@Transactional(propagation=Propagation.REQUIRES_NEW)<br>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务</li><li>@Transactional(propagation=Propagation.MANDATORY)<br>必须在一个已有的事务中执行,否则抛出异常</li><li>@Transactional(propagation=Propagation.NEVER)<br>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)</li><li>@Transactional(propagation=Propagation.SUPPORTS)<br>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java自定义注解</title>
      <link href="/2020/05/03/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/05/03/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近看项目代码的时候看到了前辈们的写的自定义注解，决定深入的学习一下自定义注解相关的知识。</p><h2 id="1-注解知识介绍"><a href="#1-注解知识介绍" class="headerlink" title="1 注解知识介绍"></a>1 注解知识介绍</h2><h3 id="1-1-注解的定义"><a href="#1-1-注解的定义" class="headerlink" title="1.1 注解的定义"></a>1.1 注解的定义</h3><p>一般在项目中声明在annotation包中，声明用@interface表示</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BussinessLog &#123;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-元注解介绍"><a href="#1-2-元注解介绍" class="headerlink" title="1.2 元注解介绍"></a>1.2 元注解介绍</h3><p>元注解的作用就是负责注解其他注解。<br>常见的有四种注解：</p><h4 id="1-2-1-Inherited"><a href="#1-2-1-Inherited" class="headerlink" title="1.2.1 @Inherited"></a>1.2.1 @Inherited</h4><p> @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。<br> 比如，注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。</p><h4 id="1-2-2-Retention"><a href="#1-2-2-Retention" class="headerlink" title="1.2.2 @Retention"></a>1.2.2 @Retention</h4><p> 用来说明该注解类的生命周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE) </span><br><span class="line"> <span class="comment">//注解只在源码阶段保留，在编译器完整编译之后，它将被丢弃忽视</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS) </span><br><span class="line"> <span class="comment">//默认，注解只被保留到编译进行的时候，它并不会被加载到 JVM 中</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  </span><br><span class="line"> <span class="comment">//注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们，大部分的注解都是 RUNTIME 的生命周期。</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-Target"><a href="#1-2-3-Target" class="headerlink" title="1.2.3 @Target"></a>1.2.3 @Target</h4><p> 表明注解的作用目标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)                          <span class="comment">// 接口、类、枚举、注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)                         <span class="comment">// 字段、枚举的常量</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)                        <span class="comment">// 方法</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)                     <span class="comment">// 方法参数</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.CONSTRUCTOR)                   <span class="comment">// 构造函数</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.LOCAL_VARIABLE)                <span class="comment">// 局部变量</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)               <span class="comment">// 注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PACKAGE)                       <span class="comment">// 包</span></span><br></pre></td></tr></table></figure><h4 id="1-2-4-Document"><a href="#1-2-4-Document" class="headerlink" title="1.2.4 @Document"></a>1.2.4 @Document</h4><p>@Documented 是一个简单的标记注解，表示是否将注解信息添加在 Java 文档，即 Javadoc 中。</p><h3 id="1-3-注解的属性"><a href="#1-3-注解的属性" class="headerlink" title="1.3 注解的属性"></a>1.3 注解的属性</h3><p>可以查看@RequestMapping的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的属性也叫做成员变量。注解只有<strong>成员变量</strong>，没有方法。注解的成员变量在注解的定义中以无形参的方法形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。<br>注解可以有默认值，需要用 <strong>default</strong> 关键字指定</p><h2 id="2-自定义注解示例"><a href="#2-自定义注解示例" class="headerlink" title="2 自定义注解示例"></a>2 自定义注解示例</h2><p>自定义@permission注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限注解 用于检查权限 规定访问权限</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span> <span class="doctag">@Permission</span>(&#123;role1,role2&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span> <span class="doctag">@Permission</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Permission &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;角色英文名称&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;使用注解时加上这个值表示限制只有某个角色的才可以访问对应的资源&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;常用在某些资源限制只有超级管理员角色才可访问&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注解的使用"><a href="#3-注解的使用" class="headerlink" title="3 注解的使用"></a>3 注解的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Permission</span>(Const.ADMIN_NAME)</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/edit"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tip <span class="title">edit</span><span class="params">(BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GunsException(ExceptionEnum.REQUEST_NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.menuService.updateById(menu);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS_TIP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring自动注入单例和多例如何选择</title>
      <link href="/2020/05/03/Spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E5%8D%95%E4%BE%8B%E5%92%8C%E5%A4%9A%E4%BE%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/"/>
      <url>/2020/05/03/Spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E5%8D%95%E4%BE%8B%E5%92%8C%E5%A4%9A%E4%BE%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring中bean的scope属性，有如下5种类型："><a href="#Spring中bean的scope属性，有如下5种类型：" class="headerlink" title="Spring中bean的scope属性，有如下5种类型："></a>Spring中bean的scope属性，有如下5种类型：</h3><p><strong>singleton</strong> 表示在spring容器中的单例，通过spring容器获得该bean时总是返回唯一的实例</p><p><strong>prototype</strong> 表示每次获得bean都会生成一个新的对象</p><p><strong>request</strong> 表示在一次http请求内有效（只适用于web应用）</p><p><strong>session</strong> 表示在一个用户会话内有效（只适用于web应用）</p><p><strong>globalSession</strong> 表示在全局会话内有效（只适用于web应用）</p><p><em>在多数情况，我们只会使用singleton和prototype两种scope</em>，如果在spring配置文件内未指定scope属性，默认为singleton。</p><a id="more"></a><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>所谓单例就是所有的请求都用一个对象来处理，比如我们常用的service和dao层的对象通常都是单例的，而多例则指每个请求用一个新的对象来处理</p><p><strong>之所以用单例，是因为没必要每个请求都新建一个对象，这样子既浪费CPU又浪费内存； 之所以用多例，是为了防止并发问题。</strong></p><p>即一个请求改变了对象的状态，此时对象又处理另一个请求，而之前请求对对象状态的改变导致了对象对另一个请求做了错误的处理；</p><p>用单例和多例的标准只有一个： <strong>当对象含有可改变的状态时（更精确的说就是在实际应用中该状态会改变），则多例，否则单例</strong>；</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://blog.csdn.net/zhang_dianliang/article/details/76850906" target="_blank" rel="noopener">https://blog.csdn.net/zhang_dianliang/article/details/76850906</a></p><p><a href="https://www.imooc.com/wenda/detail/385159" target="_blank" rel="noopener">https://www.imooc.com/wenda/detail/385159</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie和session的区别</title>
      <link href="/2020/04/30/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/30/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="http无状态和session"><a href="#http无状态和session" class="headerlink" title="http无状态和session"></a>http无状态和session</h2><p>由于HTTP协议是<strong>无状态</strong>的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.</p><a id="more"></a><p>典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。</p><p>这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。</p><p>集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候Session信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放Session。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。</p><p>实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。</p><p>有人问，如果客户端的浏览器禁用了Cookie怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p><p>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</p><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><p>所以，总结一下：<em>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式</em>。</p><p>cookie和session的<strong>共同之处</strong>在于：cookie和session都是用来<strong>跟踪浏览器用户身份</strong>的会话方式。</p><p>cookie 和session的<strong>区别</strong>是：cookie数据保存在<strong>客户端</strong>，session数据保存在<strong>服务器端</strong>。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.imooc.com/article/3369" target="_blank" rel="noopener">https://www.imooc.com/article/3369</a><br><a href="https://www.zhihu.com/question/19786827/answer/28752144" target="_blank" rel="noopener">https://www.zhihu.com/question/19786827/answer/28752144</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何通俗易懂的理解翻墙</title>
      <link href="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/"/>
      <url>/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<p><strong>为了更好的理解翻墙，首先先了解一下互联网是怎么工作的：</strong></p><a id="more"></a><h2 id="互联网怎么工作的"><a href="#互联网怎么工作的" class="headerlink" title="互联网怎么工作的"></a>互联网怎么工作的</h2><p>假如没有互联网，我们家里有两台电脑，这两台电脑需要互相发送文件，那我们需要用网线把他们连起来，就可以互相传输文件了</p><img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/two_computers.png" class="" title="two computers"><p>假如我们又增加了三台电脑，一共有五台电脑，那么我们就把他们一对一的连接起来，每台电脑都需要4个网线接口，就组成了一个局域网。</p><img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/five_computers.png" class="" title="five computers"><p>但是如果我们继续增加电脑，就会发现这种一对一的连接方式就会非常复杂了，所以这个时候就增加了一个控制中心，这个控制中心就是我们熟悉的<strong>路由器</strong>。</p><p>每台电脑只需要连接路由器，然后路由器统一协调这些电脑之前的传输问题</p><img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/router.png" class="" title="router"><p>然后我们再往大了想，如果我们想给同学家发文件，也就是一个局域网向另外一个局域网发送文件，我们就只需要把两家的路由器连上就可以发送文件了。</p><img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/two_routers.png" class="" title="two routers"><p>继续往下想就会发现开始的问题，各个局域网的路由器进行一对一的连接变得异常复杂。</p><p>所以我们就新增了一个控制中心<strong>ISP</strong>，也就是我们说的互联网服务供应商，我们可以把它想象成更大号的路由器。</p><img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/ISP.png" class="" title="two ISP"><p>这里家里的路由器只需要连接我们这个区域的ISP。</p><p>各个区域的ISP进行连接，这样我们的互联网就形成了。</p><h2 id="翻墙的原理"><a href="#翻墙的原理" class="headerlink" title="翻墙的原理"></a>翻墙的原理</h2><p>先说一下现象，我们访问部分网站，比如google的时候就会出现下面的现象：</p><img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/page_not_found.png" class="" title="page not found"><p>我们输入一个网址访问一个网站，其实就是通过DNS找到网址对应的IP地址，然后访问网站的服务器，从网站服务器获取相应信息</p><img src="/2020/04/29/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E7%BF%BB%E5%A2%99/DNS.png" class="" title="DNS"><p>举个例子：</p><p>比如小明通过百度经常访问大姐姐小姐姐的视频网站，然后百度就把这个情况向爸爸反映了，小明的爸爸为了小明的健康，就<strong>让DNS服务器不再查询大姐姐小姐姐网站的IP地址</strong>，这样小明就打不开网站了。</p><p>但是小明通过<strong>修改电脑host</strong>的方式，再一次成功的访问了网站，小明爸爸一气之下在网络传输中增加了一个关卡，告诉关卡看见数据包有大姐姐小姐姐字样的都不能通过，小明就又打不开网站了。</p><p>然后网站就给<strong>数据包加密</strong>，本来数据包上写的是大姐姐小姐姐，加密之后写的是办公用品，小明又一次打开了网站。小明爸爸又告诉关卡，只要是这个网站的IP地址都不能通过，所以小明又打不开网站了。</p><p>然后小明想了一个办法，<strong>把发送出去的数据包先进行完全的加密，通过关卡之后先传到另外一个服务器上，让这个服务器把数据包解密，然后让这个服务器去访问大姐姐小姐姐的网站，收到网站的数据包之后，服务器再进行完全的加密，通过关卡之后再解密，</strong>这样小明就再一次打开了网站。</p><h2 id="VPN翻墙原理"><a href="#VPN翻墙原理" class="headerlink" title="VPN翻墙原理"></a>VPN翻墙原理</h2><p>有些网站我们是没有办法打开的，这个是因为这中间有一个<strong>长城防火墙</strong>(GFW)，这个防火墙的作用就是检查这些数据包。</p><p>比如我们打开一个网站，DNS服务器就会告诉我们电脑，没有查到这个网址所对应的IP地址或者是长城防火墙发现这些数据包是被屏蔽网站的IP地址，就会把数据包拦下，这个就是我们没办法访问被屏蔽网站的原因。</p><p>为了能访问这些被屏蔽的网站，我们就用到了VPN。</p><p>当我们打开VPN之后，VPN就会在电脑上<strong>虚拟出一个IP地址</strong>。当电脑要传输数据包的时候，这个即将传输的数据包和没有开VPN的时候一样，先用盒子装好，然后写上寄件人和收件人的IP地址。</p><p>之后这个数据包会交给电脑的VPN，VPN就会对这个数据包进行加密，相当于又给数据包套了一个盒子，然后这个盒子的寄件人地址写的是刚才虚拟出来的IP地址，收件人地址写的是VPN服务器的IP地址，然后这个数据包就可以发送出去了。</p><p>因为<strong>这个数据包的目的地并不是被屏蔽网站的IP地址，而且数据包也加过密</strong>，防火墙自然也检测不出什么问题。</p><p>当数据包到了VPN的服务器之后，就会对数据包解密，再把里面的数据传给网站的服务器，网站服务器再传数据包给VPN服务器，VPN服务器把数据加密之后，又传回给我们，这个就是VPN的工作原理。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.youtube.com/watch?v=EUKmF_IKttc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EUKmF_IKttc</a><br><a href="https://www.youtube.com/watch?v=ZT-q6mJ-e3g" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ZT-q6mJ-e3g</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
